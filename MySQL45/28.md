## kill

kill 并不是马上停止的意思，而是告诉执行线程，这条语句已经不需要继续执行了，可以开始“执行停止的逻辑了”

`kill query thread_id_B'
  1. 把 session B 的运行状态改成`THD::KILL_QUERY`（将变量 killed 赋值为 THD::KILL_QUERY)
  1. 给 session B 的执行线程发一个信号
    - 让 session B 退出等待，来处理`THD::KILL_QUERY`的状态

 kill 无效的情况
   - 线程没有执行到判断线程状态的逻辑
   - IO 压力过大，读写 IO 的函数一直无法返回，导致不能及时判断线程状态
   - 终止逻辑耗时过长
     - 超大事务执行期间被 kill，回滚操作复杂，耗时长
     - 大查询回滚，查询过程产生大量临时文件，删除临时文件需要大量 IO 资源
     - DDL 命令执行到最后阶段，也要删除产生的临时文件

执行 Ctrl+C 的时候，是 MySQL 客户端另外启动一个连接，然后发送一个 kill query 命令，不能直接终止线程

当一个库中的表个数非常多的时候，打开慢其实是客户端慢，不是服务端慢

客户端连接
 - 执行 show databases
 - 切到 db1 库，执行 show tables
 - 把这两个命令的结果用于构建一个本地的哈希表（表多时耗时长，用于自动补全，连接命令加上`-A/-quick`可以关闭补全）
