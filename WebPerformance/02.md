## 服务器并发处理能力

### 吞吐率：单位时间内服务器处理的请求数

- 最大吞吐率（Requests per second）：单位时间内服务器能够处理的最大请求数

- 压测前提条件
    - 并发用户数：某一时刻同时向服务器发送请求的用户总数
    - 总请求数：
    - 请求资源描述

![](https://github.com/ltf9651/Blog/blob/master/WebPerformance/picture/PRS.png)


### CPU并发计算

#### 进程
- 资源分配的最小单位
- 大多数进程的时间主要消耗在I/O操作
- 进程由内核调度，进程的目的是担当分配系统资源的实体
- 进程也可以认为是记录程序实例当前运行到什么程度的一组数据，多个进程通过不同的进程描述符与这些数据进行关联
- 每个进程都拥有独立的内存地址和生命周期，当子进程被父进程创建后，便将父进程地址空间的所有数据复制到自己的地址空间，完全继承父进程的上下文信息，它们之间可以通信又互不依赖，也无权干涉各自的地址空间
- 进程的创建使用folk()系统调用，在繁忙的服务器上频繁的创建进程其开销可能成为影响性能的主要因素

#### 线程
- 轻量级进程
- 操作系统调度（CPU调度）执行的最小单位
- 由于进程之间相互独立，各自维护庞大的地址空间和上下文信息，无法很好的低成本共享数据，当采用大量进程的Web服务器在处理大量并发请求时，内存的大量消耗会成为制约性能的因素。
- 进程优势：相互独立，稳定，健壮
- 轻量级进程：系统调用clone()创建，内核直接管理，像普通进程一样独立存在，各自拥有独立进程描述符，但是共享地址空间、打开的文件等，减少内存开销

#### 协程
- 比线程更加轻量级的存在，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源

#### 进程调度器
- 内核中的进程调度器维护着各种状态的的进程队列（Run Quene），包括所有可运行程序的队列和所有休眠进程和僵尸进程的队列
- 进程调度器决定下一个运行的进程，每个进程会告诉进程调度器进程运行的紧急情况，成为进程优先级
- 进程优先级除了由进程自身决定，进程调度器在进程运行时也可以动态调整
- 给每个CPU分配一个运行队列，互不影响，进程调度器负责将进程分配到合适的CPU

#### 进程切换
- 进程调度器在必要的时候挂起正在运行的进程，同时恢复以前挂起的某个进程，称为进程切换
- 一个进程被挂起的本质：将它在CPU寄存器中的数据取出暂时存入内核态堆栈
- 恢复本质：将它的数据重新装入CPU寄存器
- 减少进程切换有利于提升系统并发出能力

#### IOWait
- CPU空闲并且等待I/O操作完成的时间比例
- 性能监控工具：Nmon，Lighthttpd

#### 锁竞争
- 锁：防止资源竞争抢占导致数据错乱，保证线程安全
- 允许的情况下关闭Web服务器访问日志可大大减少锁等待的延迟时间

### 系统调用
- Linux进程设计运行模式
    - 用户态
    - 内核态
- 提高系统底层安全性和简化开发模型
- 系统调用涉及进程从用户态切换到内核态，导致一定的内存空间交换（上下文切换），所以开销昂贵

### 内存分配
- Apache（多进程模型）: 采用基于内存池策略的内存管理方案，在运行一开始就申请大量的内存作为内存池，随后只需从内存池中直接获取，不需要再次分配，内存管理更加安全，内存池在Apache关闭时释放
- 单进程: 使用多线程处理请求，使得多线程之间可以共享内存资源，内存使用量大大减少。同时使用分阶段的内存分配策略，按需分配，及时释放

### 持久连接（Keep-Alive)
- 短连接：建立连接后发送一份数据后马上断开，频繁的使用性能开销大
- 长连接：系统调用少，性能开销少，但是使用不当会导致Web服务器维护大量的空闲进程，影响性能

### DMA（Direct Memory Access)
可以不经过CPU而直接进行磁盘和内存的数据交换，降低了CPU的占有率，节省系统资源