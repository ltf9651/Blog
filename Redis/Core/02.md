## 持久化

### AOF

WAL(Write Ahead Log)：实际写数据前先把修改的数据记录到日志文件
AOF：写后日志，Redis 先执行命令把数据写入内存，再记录日志

为了避免额外的检查开销，Redis 在向 AOF 里面记录日志的时候，并不会先去对这些命令进行语法检查。所以，如果先记日志再执行命令的话，日志中就有可能记录了错误的命令，Redis 在使用日志恢复数据时，就可能会出错，而后写日志只有命令执行成功才会记录日志，可以避免出现记录错误命令的情况。而且 AOF 不会阻塞当前的写操作

AOF 风险
  - 如果刚执行完一个命令，还没有来得及记日志就宕机了，那么这个命令和相应的数据就有丢失的风险。如果此时 Redis 是用作缓存，还可以从后端数据库重新读入数据进行恢复，但是，如果 Redis 是直接用作数据库的话，此时，因为命令没有记入日志，所以就无法用日志进行恢复了
  - AOF 虽然避免了对当前命令的阻塞，但可能会给下一个操作带来阻塞风险。这是因为，AOF 日志也是在**主线程**中执行的，如果在把日志文件写入磁盘时，磁盘写压力大，就会导致写盘很慢，进而导致后续的操作也无法执行了

AOF appendfsync
  - Always 每个写命令执行完立即将日志写入磁盘。可靠性高，数据基本不丢失但对性能影响较大
  - Everysec 每个写命令执行完，只是先把日志写到 AOF 文件内存缓冲区，每隔一秒把缓冲区的内容写入磁盘。宕机时丢失 1 秒的数据
  - No 每个写命令执行完，只是先把日志写到内存缓冲区，由操作系统决定何时写入磁盘。性能最好，宕机时丢失数据最多

AOF 重写机制：Redis 根据数据库的现状创建一个新的 AOF 文件，读取数据库中的所有键值对，然后对每一个键值对用一条命令记录它的写入。此机制可以把就日志文件中的多条命令在重写后的新日志变成一条命令，减小 AOF 文件体积，提升 AOF 写入性能。但是重写过程耗时

重写过程是由后台线程 bgrewriteaof 来完成的，这也是为了避免阻塞主线程，导致数据库性能下降
  - 每次执行重写时，主线程 fork 出后台的 bgrewriteaof 子进程。此时，fork 会把主线程的内存拷贝一份给 bgrewriteaof 子进程，这里面就包含了数据库的最新数据。然后，bgrewriteaof 子进程就可以在不影响主线程的情况下，逐一把拷贝的数据写成操作，记入重写日志
  - 因为主线程未阻塞，仍然可以处理新来的操作。此时，如果有写操作，第一处日志就是指正在使用的 AOF 日志，Redis 会把这个操作写到它的缓冲区。这样一来，即使宕机了，这个 AOF 日志的操作仍然是齐全的，可以用于恢复
  - 新的 AOF 重写日志。这个操作也会被写到重写日志的缓冲区。这样，重写日志也不会丢失最新的操作。等到拷贝数据的所有操作记录重写完成后，重写日志记录的这些最新操作也会写入新的 AOF 文件，以保证数据库最新状态的记录。此时，就可以用新的 AOF 文件替代旧文件了。新的日志文件不与原本的 AOF 日志共享，因为多进程同时写会出现竞争性能问题，且新日志重写过程中若出现失败会污染原 AOF 日志

用 AOF 方法进行故障恢复的时候，需要逐一把操作日志都执行一遍。如果操作日志非常多，Redis 就会恢复得很缓慢，影响到正常使用

### RDB

内存快照：内存中的数据在某一个时刻的状态记录

Redis 通过`bgsave`执行全量快照，不影响主线程
  - bgsave 子进程由主进程 fork 生成，共享主进程的内存数据
  - bgsave 子进程读取主线程内存数据，写入 RDB 文件
  - 此时若主线程要修改数据，将此数据复制一份生成副本，bgsave 子进把副本数据写入 RDB（快照执行期间数据不能被修改，使用写时复制）

写时复制：主线程在有写操作时，才会把这个新写或修改后的数据写入到一个新的物理地址中，并修改自己的页表映射

跟 AOF 相比，快照的恢复速度快，但是，快照的频率不好把握，如果频率太低，两次快照间一旦宕机，就可能有比较多的数据丢失。如果频率太高，又会产生额外开销

Redis 4.0 使用混合使用 AOF 日志和内存快照的方法。内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作

数据不能丢失时，内存快照和 AOF 的混合使用是一个很好的选择

如果允许分钟级别的数据丢失，可以只使用 RDB

如果只用 AOF，优先使用 everysec 的配置选项，因为它在可靠性和性能之间取了一个平衡
