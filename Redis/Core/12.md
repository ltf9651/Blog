## 主从数据一致性

主从数据可能会由于网络延迟、从库压力大处理慢等问题出现数据延迟，导致主库在数据修改后，客户端读从库的数据依然出现滞后

解决
  - 尽量保证主从库的网络连接状况良好，避免部署在不同机房，或者网络通信密集的地方
  - 监控复制进度：`INFO replication`，如果从库进度值过大，先禁止该从库提供数据服务，等待赶上进度后再上线

[过期策略](https://github.com/ltf9651/Blog/blob/master/Redis/23.md)

有些命令给数据设置的过期时间在从库上可能会被延后，导致应该过期的数据又在从库上被读取到，在业务应用中使用 EXPIREAT/PEXPIREAT 命令，把数据的过期时间设置为具体的时间点，避免读到过期数据

合理配置
  - protected-mode 设置为 no
  - cluster-node-timeout 数值调大
  - slave-serve-stale-data 设置为 no

slave-serve-stale-data 是在主从复制中从服务器是否可以响应客户端的请求，slave-read-only 是设置从库能否处理写命令

主从库设置的 maxmemory 不同，如果 slave 比 master 小，那么 slave 内存就会优先达到 maxmemroy，然后开始淘汰数据，此时主从库也会产生不一致

如果主从同步的 client-output-buffer-limit 设置过小，并且 master 数据量很大，主从全量同步时可能会导致 buffer 溢出，溢出后主从全量同步就会失败。如果主从集群配置了哨兵，那么哨兵会让 slave 继续向 master 发起全量同步请求，然后 buffer 又溢出同步失败，如此反复，会形成复制风暴，这会浪费 master 大量的 CPU、内存、带宽资源，也会让 master 产生阻塞的风险
