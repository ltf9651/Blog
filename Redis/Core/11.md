## ACID

### 原子性

命令入队时就报错，会放弃事务执行，保证原子性

命令入队时没报错，实际执行时报错，不保证原子性

EXEC 命令执行时实例故障，如果开启了 AOF 日志，可以保证原子性

EXEC 命令执行时实例故障，如果使用 RDB
  - 假设事务在执行到一半时，实例发生了故障，在这种情况下，上一次 RDB 快照中不会包含事务所做的修改，而下一次 RDB 快照还没有执行。所以，实例恢复后，事务修改的数据会丢失，事务的原子性能得到保证
  - 假设事务执行完成后，RDB 快照已经生成了，如果实例发生了故障，事务修改的数据可以从 RDB 中恢复，事务的原子性也就得到了保证
  - 假设事务执行已经完成，但是 RDB 快照还没有生成，如果实例发生了故障，那么，事务修改的数据就会全部丢失，也就谈不上原子性了

### 一致性

在命令执行错误或 Redis 发生故障的情况下，Redis 事务机制对一致性属性是有保证的

命令入队时就报错时，事务会被放弃执行

命令入队时没报错，出队时报错，错误的命令不会执行，正确的命令会执行，不会改变一致性

发生故障时，AOF 和 RDB 在数据恢复后也能保证一致

### 隔离性

并发操作在 EXEC 命令前执行，此时，隔离性的保证要使用 WATCH 机制来实现，否则隔离性无法保证

并发操作在 EXEC 命令后执行，此时，隔离性可以保证

WATCH 机制：在事务执行前，监控一个或多个键的值变化情况，当事务调用 EXEC 命令执行时，会先检查监控的键是否被其它客户端修改了。如果修改了，就放弃事务执行，避免事务的隔离性被破坏。然后，客户端重试，再次执行事务，此时，如果没有并发修改事务数据的操作了，事务就能正常执行，隔离性也得到了保证

### 持久性

不管 Redis 采用什么持久化模式，事务的持久性属性是得不到保证的
