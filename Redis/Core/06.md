## 异步机制

Redis 阻塞点
  - 客户端
    - 网络 IO：Redis 使用了 IO 多路复用机制，避免网络等待状态，网络 IO 不是阻塞点
    - 键值对增删改查：高复杂命令、bigkey 删除操作可能产生阻塞（释放大量内存）
    - 数据库操作：清空数据库涉及删除和释放所有键值对，会阻塞
  - 磁盘
    - 生成 RDB 快照
    - 记录 AOF 日志
    - AOF 日志重写
    - Redis 涉及采用子进程的方式生成 RDB 文件和 AOF 重写，慢速磁盘 IO 不会阻塞
    - 直接记录 AOF 会根据不同写回策略落盘，如果大量的写操作需要记录 AOF 并同步写回，会阻塞
  - 主从节点
    - 主库生成
    - 传输 RDB 文件
    - 从库接收 RDB 文件
    - 加载 RDB
    - 清空数据库
    - 主库在复制的过程中，创建和传输 RDB 文件都是由子进程来完成的，不会阻塞主线程
    - 从库在接收 RDB 后需要使用`flushdb`清空数据库，加载 RDB 到内存，会产生阻塞
  - 切片集群实例
    - 向其他实例传输哈希槽信息：哈希槽的信息量不大，而数据迁移是渐进式执行的，一般这两类操作对 Redis 主线程的阻塞风险不大
    - 数据迁移：迁移 bigkey 的话，就会造成主线程的阻塞

阻塞点
  - 集合全量查询和聚合操作：可以使用`SCAN`命令，分批读取数据，再在客户端进行聚合计算
  - bigkey 删除
  - 清空数据库
  - AOF 日志同步写
  - 从库加载 RDB 文件：把主库的数据量大小控制在 2~4GB 左右，以保证 RDB 文件能以较快的速度加载

如果一个操作能被异步执行，就意味着，它并不是 Redis 主线程的关键路径上的操作（客户端把请求发送给 Redis 后，等着 Redis 返回数据结果的操作）

读操作属于关键操作，需要客户端返回具体的数据信息，所以集合全量查询和聚合操作不能异步

bigkey 删除和清空数据库不需要客户端获取具体数据，可以异步

AOF 日志同步写可以异步启动子线程执行，而不用让主线程等待

从库加载 RDB 时，从库需要提供数据服务就必须等待 RDB 加载完成，必须让从库的主线程执行，不能异步操作

### 异步子线程机制

Redis 主线程启动后，会使用操作系统提供的`pthread_create`函数创建 3 个子线程，分别由它们负责 AOF 日志写操作、键值对删除以及文件关闭的异步执行

主线程通过一个链表形式的任务队列和子线程进行交互。当收到键值对删除和清空数据库的操作时，主线程会把这个操作封装成一个任务，放入到任务队列中，然后给客户端返回一个完成信息，表明删除已经完成，此时真正的删除还没执行，等到后台子线程从任务队列读取任务后真正开始执行删除操作（lazy free/unlink）

当 AOF 日志配置成 everysec 选项后，主线程会把 AOF 写日志操作封装成一个任务，也放到任务队列中。后台子线程读取任务后，开始自行写入 AOF 日志，这样主线程就不用一直等待 AOF 日志写完
