## Redis 基础

1. 所有操作在内存上完成，内存访问速度快
1. 键值对按照一定的数据结构来组织，操作键值对就是对数据结构进行增删改查，高效的数据结构是快的基础

为了实现从键到值的快速访问，Redis 使用了一个哈希表来保存所有键值对。一个哈希表由多个哈希桶组成，每个哈希桶中保存了键值对数据。哈希桶中的元素保存的不是值本身，而是具体指向值的指针

哈希表的时间复杂度 O(1)，通过计算键的哈希值快速定位哈希桶位置，访问相应的 entry 元素（保存`*key` 和`*value`）

哈希表隐患：哈希冲突和 rehash 可能带来的操作阻塞

Redis 通过链式哈希解决哈希冲突：同一个哈希桶中的多个元素用一个链表保存，他们之间依次用指针连接

当哈希冲突越多，链表越长，查找效率会降低。此时 Redis 会通过 rehash 哈希表，增加现有的哈希桶数量，减少单个桶中元素，从而减少冲突

为了使 rehash 更高效，Redis 默认使用两个全局哈希表，一开始插入数据时默认使用表 1

rehash
  - 给哈希表 2 分配更大的空间，例如是当前哈希表 1 大小的两倍
  - 把哈希表 1 中的数据重新映射并拷贝到哈希表 2 中
  - 释放哈希表 1 的空间

rehash 本质是通过切换哈希表，用增大后的表保存更多数据，而原来的表留作下一次 rehash 备用

rehash 涉及大量数据拷贝，一次性操作会导致阻塞，服务中断。Redis 采用渐进式 rehash

在拷贝数据时 Redis 扔正常处理请求，在处理请求时从表 1 的第一个索引位置开始顺带将这个索引位置上的所有数据拷贝到表 2，等处理下一个请求时在顺带拷贝表 1 的下一个索引位置的数据

### 高性能 IO

Redis 单线程是指它对网络 IO 和数据读写的操作采用了一个线程，而采用单线程的一个核心原因是避免多线程开发的并发控制问题
  - 多线程并发访问控制复杂，涉及互斥锁、资源保护等，开销大
  - 多线程开发一般会引入同步原语来保护共享资源的并发访问，提升开发维护难度

**Redis 采用多路复用机制**，在值运行单线程的模式下，内核一直监听连接或数据请求，一旦有请求到达就交给 Redis 线程处理，不会阻塞在某一个特定的客户端请求，实现一个 Redis 线程处理多个 IO 流的效果。这些时间会被放进一个时间队列，Redis 线程对该队列不断进行处理，无需轮询是否有请求实际发生，避免造成 CPU 资源浪费，同时及时响应客户端请求，提升性能

Redis 的多 IO 线程只是用来处理网络请求的，对于读写命令，Redis 仍然使用单线程来处理

Redis 新增客户端缓存功能，数据没有变化时，业务直接在应用进程内就能拿到数据，这不仅节省了网络带宽，降低了 Redis 的请求压力

## Redis 应用场景

1. 记录帖子的点赞数、评论数和点击数 (hash)。
1. 记录用户的帖子 ID 列表 （排序），便于快速显示用户的帖子列表 (zset)。
1. 记录帖子的标题、摘要、作者和封面信息，用于列表页展示 (hash)。
1. 记录帖子的点赞用户 ID 列表，评论 ID 列表，用于显示和去重计数 (zset)。
1. 缓存近期热帖内容 （帖子内容空间占用比较大），减少数据库压力 (hash)。
1. 记录帖子的相关文章 ID，根据内容推荐相关帖子 (list)。
1. 如果帖子 ID 是整数自增的，可以使用 Redis 来分配帖子 ID（计数器）。
1. 收藏集和帖子之间的关系 (zset)。
1. 记录热榜帖子 ID 列表，总热榜和分类热榜 (zset)。
1. 缓存用户行为历史，进行恶意行为过滤 (zset,hash)。

[Redis面试题](https://mp.weixin.qq.com/s/-y1zvqWEJ3Tt4h39Z0WBJg)

### 未来趋势：NVM 内存

能持久化保存数据，读写速度和 DRAM 接近，容量大

### 缓存策略

一个系统中的不同层之间的访问速度不一样，所以才需要缓存，这样就可以把一些需要频繁访问的数据放在缓存中，以加快它们的访问速度 (CPU > Memory > disk)

pika：基于 SSD 实现大容量 Redis

使用 SSD 替代内存的优势
  - 容量大、成本低
  - 重启快，不需要加载 AOF、RDB
  - 同步风险低

劣势：性能不如内存

优化
  - 利用 Pika 的多线程模型，增加线程数量，提升 Pika 的并发请求处理能力
  - 为 Pika 配置高配的 SSD，提升 SSD 自身的访问性能
