## 队列

客户端通过`pop`获取 redis list 的消息，如果队列空了客户端就会陷入 pop 死循环，没有数据接着 pop，空轮训不但拉高了客户端的 CPU，redis 的 QPS 也会被拉高，redis 慢查询会增多

可通过`blpop/brpop`阻塞的方法代替`lpop/rpop`解决，当队列没有数据的时候会进入休眠状态，一旦数据到来就立刻醒过来

但是如果线程一直阻塞，redis 的客户端连接就会变成闲置状态，如果闲置过久服务器会主动断开以减少资源占用，这时候`blpop/brpop`就会抛出异常

`pop/blpop`等命令出消息后，队列中就没这个消息了，如果处理消息的程序拿到消息还未处理就挂掉了，那消息就丢失了，所以是不可靠队列，可通过`rpoplpush/brpoplpush`增加可靠性

使用`rpoplpush`要注意顺序和一般是相反的，使用前要在队列插入元素时使用`lpush`

### 延时队列

通过 zset 实现，将消息序列化成一个字符串作为 zset 的 value，消息的到期时间作为 score，然后多个线程轮询 zset 获取到期的任务进行处理（多个线程保证可用性）

当线程拿到消息后通过`zrem`从队列中删除此消息，因为是多线程并发争抢任务，要确保任务只执行一次（通过`zrem`的返回值确定）

同一个任务可能会被多个进程取到之后再使用 zrem 进行争抢，那些没抢到的进程都是白取了一次任务，这是浪费。可以考虑使用 lua scripting 来优化一下这个逻辑，将 zrangebyscore 和 zrem 一同挪到服务器端进行原子化操作，这样多个进程之间争抢任务时就不会出现这种浪费
