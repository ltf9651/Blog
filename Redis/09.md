## 线程IO模型

Redis虽然是个**单线程程序**，但是所有的数据都存在**内存**中，所有的运算都是内存级别的运算，所以速度快。

由于是单线程所以要注意时间复杂度为O(n)级别的指令，容易造成卡顿

Redis处理多并发客户端连接的利器：多路复用、select系列的事件轮询API，非阻塞IO

### 非阻塞IO
阻塞：比如`read`方法要传递进去一个参数n，表示最多读取这么多字节后再返回，如果一个字节都没有，那么线程就会卡在那里，直到新的数据到来或者连接关闭了，read方法才可以返回，线程才能继续处理

非阻塞：能读多少读多少，能写多少写多少，读写可以瞬间完成然后线程可以继续干别的事了

### 事件轮询（多路复用）
非阻塞IO的线程在退出后需要通知来完成新数据的处理

多路复用API：`epoll(linux)`
```py
read_events, write_events = select(read_fds, write_fds, timeout)
for event in read_events:
    handle_read(event.fd)
for event in write_events:
    handle_write(event.fd)
handle_others()  # 处理其它事情，如定时任务等
```

### 指令队列
Redis 会将每个客户端套接字都关联一个指令队列。客户端的指令通过队列来排队进行顺序处理，先到先服务。

### 响应队列
Redis 同样也会为每个客户端套接字关联一个响应队列。Redis 服务器通过响应队列来将指令的返回结果回复给客户端。 如果队列为空，那么意味着连接暂时处于空闲状态，不需要去获取写事件，等队列有数据再继续处理。

### 定时任务
Redis 的定时任务会记录在一个称为**最小堆**的数据结构中。在每个循环周期，Redis 都会将最小堆里面已经到点的任务立即进行处理。处理完毕后，将最快要执行的任务还需要的时间记录下来，如果未来某段时间内没有任务需要处理则这段时间内可以安心睡眠。