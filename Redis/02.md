## Redis 基础数据结构

- string
    - key-value
    - `set`-`get`， `mset`-`mget`， `setex`， `setnx`， `incr`， `incrby`，`expire`，`ttl`，`getrange`，`setrange`，`strlen`，`append`
    - 缓存用户信息：将用户信息结构体使用 JSON 序列化成字符串，然后将序列化后的字符串塞进 Redis 来缓存。同样，取用户信息会经过一次反序列化的过程
    - Redis 的字符串是动态字符串，可以修改，采用预分配冗余空间的方式来减少内存的频繁分配，内部为当前字符串实际分配的空间 capacity 一般要高于实际字符串长度 len。当字符串长度小于 1M 时，扩容都是加倍现有的空间，如果超过 1M，扩容时一次只会多扩 1M 的空间（类似 Golang 切片）。字符串最大长度为 512M。

- list

    - 数据结构：**链表**
    - list 的插入和删除操作非常快，时间复杂度为 O(1)，但是索引定位很慢，时间复杂度为 O(n)
    - list 弹出了最后一个元素之后，该数据结构自动被删除，内存被回收
    - list 结构常用来做异步队列使用。将需要延后处理的任务结构体序列化成字符串塞进 Redis 的列表，另一个线程从这个列表中轮询数据进行处理。
    - `rpush`，`lpop`，`lpush`，`llen`，`lindex`，`ltrim`，`lrange`

- hash
    - 无序字典
    - 数据结构：**数组 + 链表二维结构**
    - 字典的值只能是字符串
    - 渐进式 rehash 策略：在 rehash 的同时，保留新旧两个 hash 结构，查询时会同时查询两个 hash 结构，然后在后续的定时任务中以及 hash 操作指令中，循序渐进地将旧 hash 的内容一点点迁移到新的 hash 结构中。当搬迁完成了，就会使用新的 hash 结构取而代之
    - hash 结构的存储消耗要高于单个字符串
    - `hset`，`hmset`，`hget`，`hgetall`，`hincr`，`hincrby`，`hkeys`，`hvals`，`hdel`，`hexists`

- set
    - hash 结构，所有的 value 都指向同一个内部值
    - 内部的键值对无序且唯一
    - 内部实现相当于一个特殊的字典，字典中所有的 value 都是一个值`NULL`
    - 当集合中最后一个元素移除之后，数据结构自动删除，内存被回收
    - set 结构可以用来存储活动中奖的用户 ID，因为有**去重功能**，可以保证同一个用户不会中奖两次
    - `sadd`，`smembers`，`sismember`，`scard`，`spop(随机)`，`srem`

- zset
    - 底层结构
        - hash：关联元素 value 和权重 score，保障元素 value 的唯一性，可以通过 value 找到相应的 score 值
        - 跳跃链表：给元素 value 排序，根据 score 的范围获取元素列表
    - zset 可以用来存粉丝列表，value 值是粉丝的用户 ID，score 是关注时间。我们可以对粉丝列表按关注时间进行排序
    - zset 可以用来存储学生的成绩，value 值是学生的 ID，score 是他的考试成绩。我们可以对成绩按分数进行排序就可以得到他的名次
    - `zadd`，`zrange`，`zrevrange`，`zcard`，`zscore`，`zrank`，`zrangebyscore`，`zrem`
    - zset 内部的排序功能是通过**跳跃列表**数据结构

    最下面一层所有的元素都会串起来。然后每隔几个元素挑选出一个代表来，再将这几个代表使用另外一级指针串起来。然后在这些代表里再挑出二级代表，再串起来。最终就形成了金字塔结构。

    「跳跃列表」之所以「跳跃」，是因为内部的元素可能「身兼数职」，可以快速在不同层次之间进行「跳跃」。

    定位插入点时，先在顶层进行定位，然后下潜到下一级定位，一直下潜到最底层找到合适的位置，将新元素插进去。

    跳跃列表采取一个随机策略来决定新元素可以兼职到第几层。首先 L0 层肯定是 100% 了，L1 层只有 50% 的概率，L2 层只有 25% 的概率，L3 层只有 12.5% 的概率，一直随机到最顶层 L31 层。绝大多数元素都过不了几层，只有极少数元素可以深入到顶层。列表中的元素越多，能够深入的层次就越深，能进入到顶层的概率就会越大。

- 容器型数据结构
    - list/set/hash/zset 这四种数据结构是容器型数据结构
        - create if not exists：如果容器不存在，那就创建一个，再进行操作
        - drop if no elements：如果容器里元素没有了，那么立即删除元素，释放内存

- 过期时间
    - Redis 所有的数据结构都可以设置过期时间
    - 过期是以对象为单位：一个 hash 结构的过期是整个 hash 对象的过期，而不是其中的某个子 key
    - 如果一个字符串已经设置了过期时间，然后你调用了 set 方法修改了它，它的过期时间会消失


[redis](http://zhangtielei.com/posts/server.html)