### Redis 持久化

- 持久化机制
  - 快照
    - 内存数据的二进制序列化形式
    - 全量备份
  - AOF 日志
    - 内存数据修改的指令记录文本
    - 增量备份
    - 日志在长期的运行过程中会变的庞大，数据库重启时需要加载日志进行指令重放，要定期进行 AOF 重写

### 快照原理

Redis 使用操作系统的多进程 COW(Copy On Write) 机制来实现快照持久化

### fork（多进程）

Redis 在持久化时会调用 `glibc` 的函数`fork`产生一个子进程，快照持久化完全交给子进程来处理，父进程继续处理客户端请求。子进程刚刚产生时，它和父进程共享内存里面的代码段和数据段，两个进程共享内存里的代码段和数据段。

```py
pid = os.fork()
if pid > 0:
    handle_client_requests()  # 父进程继续处理客户端请求
if pid == 0:
    handle_snapshot_write()  # 子进程处理快照写磁盘
if pid < 0:
    # fork error

# fork函数会在父子进程同时返回，在父进程里返回子进程的 pid，在子进程里返回零。
# 如果操作系统内存资源不足，pid 就会是负数，表示fork失败
```

子进程做数据持久化，它不会修改现有的内存数据结构，它只是对数据结构进行遍历读取，然后序列化写到磁盘中。父进程持续服务客户端请求，然后对内存数据结构进行不间断的修改。这个时候就会使用操作系统的 COW 机制来进行数据段页面的分离。数据段是由很多操作系统的页面组合而成，当父进程对其中一个页面的数据进行修改时，会将被共享的页面复制一份分离出来，然后对这个复制的页面进行修改。这时子进程相应的页面是没有变化的，还是进程产生时那一瞬间的数据。

子进程因为数据没有变化，它能看到的内存里的数据在进程产生的一瞬间就凝固了，再也不会改变，这也是为什么 Redis 的持久化叫「快照」的原因。接下来子进程就可以非常安心的遍历数据，进行序列化写磁盘。

### AOF 原理

AOF 日志存储的是 Redis 服务器的顺序指令序列，AOF 日志只记录对内存进行修改的指令记录。

Redis 会在收到客户端修改指令后，进行参数校验进行逻辑处理后，如果没问题，就立即将该指令文本存储到 AOF 日志中，也就是先执行指令才将日志存盘。

WAL(Write Ahead Log)：实际写数据前先把修改的数据记录到日志文件

AOF：写后日志，Redis 先执行命令把数据写入内存，再记录日志

为了避免额外的检查开销，Redis 在向 AOF 里面记录日志的时候，并不会先去对这些命令进行语法检查。所以，如果先记日志再执行命令的话，日志中就有可能记录了错误的命令，Redis 在使用日志恢复数据时，就可能会出错，而后写日志只有命令执行成功才会记录日志，可以避免出现记录错误命令的情况。而且 AOF 不会阻塞当前的写操作

AOF 风险
  - 如果刚执行完一个命令，还没有来得及记日志就宕机了，那么这个命令和相应的数据就有丢失的风险。如果此时 Redis 是用作缓存，还可以从后端数据库重新读入数据进行恢复，但是，如果 Redis 是直接用作数据库的话，此时，因为命令没有记入日志，所以就无法用日志进行恢复了
  - AOF 虽然避免了对当前命令的阻塞，但可能会给下一个操作带来阻塞风险。这是因为，AOF 日志也是在**主线程**中执行的，如果在把日志文件写入磁盘时，磁盘写压力大，就会导致写盘很慢，进而导致后续的操作也无法执行了

AOF appendfsync
  - Always 每个写命令执行完立即将日志写入磁盘。可靠性高，数据基本不丢失但对性能影响较大
  - Everysec 每个写命令执行完，只是先把日志写到 AOF 文件内存缓冲区，每隔一秒把缓冲区的内容写入磁盘。宕机时丢失 1 秒的数据
  - No 每个写命令执行完，只是先把日志写到内存缓冲区，由操作系统决定何时写入磁盘。性能最好，宕机时丢失数据最多

### AOF 重写

AOF 重写机制：Redis 根据数据库的现状创建一个新的 AOF 文件，读取数据库中的所有键值对，然后对每一个键值对用一条命令记录它的写入。此机制可以把就日志文件中的多条命令在重写后的新日志变成一条命令，减小 AOF 文件体积，提升 AOF 写入性能。但是重写过程耗时

重写过程是由后台线程 bgrewriteaof 来完成的，这也是为了避免阻塞主线程，导致数据库性能下降
  - 每次执行重写时，主线程 fork 出后台的 bgrewriteaof 子进程。此时，fork 会把主线程的内存拷贝一份给 bgrewriteaof 子进程，这里面就包含了数据库的最新数据。然后，bgrewriteaof 子进程就可以在不影响主线程的情况下，逐一把拷贝的数据写成操作，记入重写日志
  - 因为主线程未阻塞，仍然可以处理新来的操作。此时，如果有写操作，第一处日志就是指正在使用的 AOF 日志，Redis 会把这个操作写到它的缓冲区。这样一来，即使宕机了，这个 AOF 日志的操作仍然是齐全的，可以用于恢复
  - 新的 AOF 重写日志。这个操作也会被写到重写日志的缓冲区。这样，重写日志也不会丢失最新的操作。等到拷贝数据的所有操作记录重写完成后，重写日志记录的这些最新操作也会写入新的 AOF 文件，以保证数据库最新状态的记录。此时，就可以用新的 AOF 文件替代旧文件了。新的日志文件不与原本的 AOF 日志共享，因为多进程同时写会出现竞争性能问题，且新日志重写过程中若出现失败会污染原 AOF 日志

用 AOF 方法进行故障恢复的时候，需要逐一把操作日志都执行一遍。如果操作日志非常多，Redis 就会恢复得很缓慢，影响到正常使用

### RDB

内存快照：内存中的数据在某一个时刻的状态记录

Redis 通过`bgsave`执行全量快照，不影响主线程
  - bgsave 子进程由主进程 fork 生成，共享主进程的内存数据
  - bgsave 子进程读取主线程内存数据，写入 RDB 文件
  - 此时若主线程要修改数据，将此数据复制一份生成副本，bgsave 子进把副本数据写入 RDB（快照执行期间数据不能被修改，使用写时复制）

写时复制：主线程在有写操作时，才会把这个新写或修改后的数据写入到一个新的物理地址中，并修改自己的页表映射

跟 AOF 相比，快照的恢复速度快，但是，快照的频率不好把握，如果频率太低，两次快照间一旦宕机，就可能有比较多的数据丢失。如果频率太高，又会产生额外开销

Redis 4.0 使用混合使用 AOF 日志和内存快照的方法。内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作

数据不能丢失时，内存快照和 AOF 的混合使用是一个很好的选择

如果允许分钟级别的数据丢失，可以只使用 RDB

如果只用 AOF，优先使用 everysec 的配置选项，因为它在可靠性和性能之间取了一个平衡

### fsync

Linux 的`glibc`提供了`fsync(int fd)`函数可以将指定文件的内容强制从内核缓存刷到磁盘，防止机器宕机导致 AOF 日志未能完全刷入磁盘。

`fsync`为磁盘 IO 操作，速度很慢，在生产环境的服务器中，Redis 通常是每隔 1s 左右执行一次 `fsync` 操作

### 运维

- 快照是通过开启子进程的方式进行的，它是一个比较耗资源的操作。
  - 遍历整个内存，大块写磁盘会加重系统负载
  - AOF 的 `fsync` 是一个耗时的 IO 操作，它会降低 Redis 性能，同时也会增加系统 IO 负担

所以通常 Redis 的主节点是不会进行持久化操作，持久化操作主要在从节点进行。从节点是备份节点，没有来自客户端请求的压力，它的操作系统资源往往比较充沛。

### Redis 4.0 混合持久化

重启 Redis 时，我们很少使用 RDB 快照 来恢复内存状态，因为会丢失大量数据。我们通常使用 AOF 日志重放，但是重放 AOF 日志性能相对 RDB 快照 来说要慢很多，这样在 Redis 实例很大的情况下，启动需要花费很长的时间。

将 RDB 快照 文件的内容和增量的 AOF 日志文件存在一起。这里的 AOF 日志不再是全量的日志，而是自持久化开始到持久化结束的这段时间发生的增量 AOF 日志，通常这部分 AOF 日志很小。

于是在 Redis 重启的时候，可以先加载 RDB 快照 的内容，然后再重放增量 AOF 日志就可以完全替代之前的 AOF 全量文件重放，重启效率因此大幅得到提升。
