### Redis持久化

- 持久化机制
  - 快照
    - 内存数据的二进制序列化形式
    - 全量备份
  - AOF日志
    - 内存数据修改的指令记录文本
    - 增量备份
    - 日志在长期的运行过程中会变的庞大，数据库重启时需要加载日志进行指令重放，要定期进行 AOF 重写

### 快照原理
Redis 使用操作系统的多进程 COW(Copy On Write) 机制来实现快照持久化

### fork(多进程)
Redis 在持久化时会调用 `glibc` 的函数`fork`产生一个子进程，快照持久化完全交给子进程来处理，父进程继续处理客户端请求。子进程刚刚产生时，它和父进程共享内存里面的代码段和数据段，两个进程共享内存里的代码段和数据段。
```py
pid = os.fork()
if pid > 0:
    handle_client_requests()  # 父进程继续处理客户端请求
if pid == 0:
    handle_snapshot_write()  # 子进程处理快照写磁盘
if pid < 0:
    # fork error

# fork函数会在父子进程同时返回，在父进程里返回子进程的 pid，在子进程里返回零。
# 如果操作系统内存资源不足，pid 就会是负数，表示fork失败
```

子进程做数据持久化，它不会修改现有的内存数据结构，它只是对数据结构进行遍历读取，然后序列化写到磁盘中。父进程持续服务客户端请求，然后对内存数据结构进行不间断的修改。这个时候就会使用操作系统的 COW 机制来进行数据段页面的分离。数据段是由很多操作系统的页面组合而成，当父进程对其中一个页面的数据进行修改时，会将被共享的页面复制一份分离出来，然后对这个复制的页面进行修改。这时子进程相应的页面是没有变化的，还是进程产生时那一瞬间的数据。

子进程因为数据没有变化，它能看到的内存里的数据在进程产生的一瞬间就凝固了，再也不会改变，这也是为什么 Redis 的持久化叫「快照」的原因。接下来子进程就可以非常安心的遍历数据，进行序列化写磁盘。

### AOF原理
AOF 日志存储的是 Redis 服务器的顺序指令序列，AOF 日志只记录对内存进行修改的指令记录。

Redis 会在收到客户端修改指令后，进行参数校验进行逻辑处理后，如果没问题，就立即将该指令文本存储到 AOF 日志中，也就是先执行指令才将日志存盘。

### AOF重写
Redis 提供了 `bgrewriteaof` 指令用于对 AOF 日志进行瘦身。其原理就是开辟一个子进程对内存进行遍历转换成一系列 Redis 的操作指令，序列化到一个新的 AOF 日志文件中。序列化完毕后再将操作期间发生的增量 AOF 日志追加到这个新的 AOF 日志文件中，追加完毕后就立即替代旧的 AOF 日志文件了，瘦身工作就完成了。

### fsync
Linux 的`glibc`提供了`fsync(int fd)`函数可以将指定文件的内容强制从内核缓存刷到磁盘，防止机器宕机导致AOF日志未能完全刷入磁盘。

`fsync`为磁盘IO操作，速度很慢，在生产环境的服务器中，Redis 通常是每隔 1s 左右执行一次 `fsync` 操作

### 运维
- 快照是通过开启子进程的方式进行的，它是一个比较耗资源的操作。
  - 遍历整个内存，大块写磁盘会加重系统负载
  - AOF 的 `fsync` 是一个耗时的 IO 操作，它会降低 Redis 性能，同时也会增加系统 IO 负担

所以通常 Redis 的主节点是不会进行持久化操作，持久化操作主要在从节点进行。从节点是备份节点，没有来自客户端请求的压力，它的操作系统资源往往比较充沛。


### Redis 4.0 混合持久化
重启 Redis 时，我们很少使用 RDB快照 来恢复内存状态，因为会丢失大量数据。我们通常使用 AOF 日志重放，但是重放 AOF 日志性能相对 RDB快照 来说要慢很多，这样在 Redis 实例很大的情况下，启动需要花费很长的时间。

将 RDB快照 文件的内容和增量的 AOF 日志文件存在一起。这里的 AOF 日志不再是全量的日志，而是自持久化开始到持久化结束的这段时间发生的增量 AOF 日志，通常这部分 AOF 日志很小。

于是在 Redis 重启的时候，可以先加载 RDB快照 的内容，然后再重放增量 AOF 日志就可以完全替代之前的 AOF 全量文件重放，重启效率因此大幅得到提升。