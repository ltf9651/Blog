## 链表

链表通过**指针**将一组**零散的内存块**串联起来使用。这些内存块成为结点，每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址，这个记录下个结点地址的指针叫作后继指针 next。


### 单链表

链表对于插入、删除的时间复杂度为O(1)，速度快，无需进行数据迁移。

链表要想随机访问第 k 个元素，就没有数组那么高效了。因为链表中的数据并非连续存储的，所以无法像数组那样，根据首地址和下标，通过寻址公式就能直接计算出对应的内存地址，而是需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点。链表随机访问的性能没有数组好，需要 O(n) 的时间复杂度。


### 循环链表

环形结构，头尾连接

### 双向链表

双指针：prev, next

支持双向遍历，更高效


### 双向循环链表


### 链表 VS 数组

1. 数组使用连续空间，可以借助CPU缓存，访问效率高
1. 链表空间不连续，无法使用CPU缓存预读数据
1. 数组大小固定，一经声明就占用内存空间
1. 链表无大小限制，支持动态扩容


CPU在从内存读取数据的时候，会先把读取到的数据加载到CPU的缓存中。而CPU每次从内存读取数据并不是只读取那个特定要访问的地址，而是读取一个数据块并保存到CPU缓存中，然后下次访问内存数据的时候就会先从CPU缓存开始查找，如果找到就不需要再从内存中取。这样就实现了比内存访问速度更快的机制，也就是CPU缓存存在的意义：为了弥补内存访问速度过慢与CPU执行速度快之间的差异而引入。

### 基于链表实现 LRU 缓存淘汰算法

思路：维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，从链表头开始顺序遍历链表。

1. 如果此数据之前已经被缓存在链表中了，遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。

2. 如果此数据没有在缓存链表中，又可以分为两种情况：

- 如果此时缓存未满，则将此结点直接插入到链表的头部；
- 如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。

