## 散列表（Hash Table)

* 散列表用的就是数组支持按照下标随机访问的时候，时间复杂度是 O(1) 的特性
* 通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置
* 当按照键值查询元素时，用同样的散列函数，将键值转化数组下标，从对应的数组下标的位置取数据。

``` C
int hash(String key) {
  // 获取后两位字符
  string lastTwoChars = key.substr(length-2, length);
  // 将后两位字符转换为整数
  int hashValue = convert lastTwoChas to int-type;
  return hashValue;
}
```

### 解决hash冲突

1. 开放寻址法：出现了散列冲突，就重新探测一个空闲位置，将其插入
1. 链表法

### Word 文档中单词拼写检查功能是如何实现的？

常用的英文单词有 20 万个左右，假设单词的平均长度是 10 个字母，平均一个单词占用 10 个字节的内存空间，那 20 万英文单词大约占 2MB 的存储空间，就算放大 10 倍也就是 20MB。对于现在的计算机来说，这个大小完全可以放在内存里面。所以可以用散列表来存储整个英文单词词典。

当用户输入某个英文单词时，拿用户输入的单词去散列表中查找。如果查到，则说明拼写正确；如果没有查到，则说明拼写可能有误，给予提示。借助散列表这种数据结构，就可以轻松实现快速判断是否存在拼写错误。

### 总结

一、为什么散列表和链表经常放在一起使用？

1. 散列表的优点：支持高效的数据插入、删除和查找操作
2. 散列表的缺点：不支持快速顺序遍历散列表中的数据
3. 如何按照顺序快速遍历散列表的数据？只能将数据转移到数组，然后排序，最后再遍历数据。
4. 知道散列表是动态的数据结构，需要频繁的插入和删除数据，那么每次顺序遍历之前都需要先排序，这势必会造成效率非常低下。
5. 如何解决上面的问题呢？就是将散列表和链表（或跳表）结合起来使用。

二、散列表和链表如何组合起来使用？

1. LRU（Least Recently Used）缓存淘汰算法

* LRU缓存淘汰算法主要操作有哪些？主要包含3个操作：
  + 往缓存中添加一个数据；
  + 从缓存中删除一个数据；
  + 在缓存中查找一个数据；
  + 总结：上面3个都涉及到查找。
* 如何用链表实现LRU缓存淘汰算法？
  + 需要维护一个按照访问时间从大到小的有序排列的链表结构。
  + 缓冲空间有限，当空间不足需要淘汰一个数据时直接删除链表头部的节点。
  + 当要缓存某个数据时，先在链表中查找这个数据。若未找到，则直接将数据放到链表的尾部。若找到，就把它移动到链表尾部。
  + LRU缓存的3个主要操作都涉及到查找，若单纯由链表实现，查找的时间复杂度很高为O(n)。若将链表和散列表结合使用，查找的时间复杂度会降低到O(1)。

* 如何使用散列表和链表实现LRU缓存淘汰算法？

  + 使用双向链表存储数据，链表中每个节点存储数据（data）、前驱指针（prev）、后继指针（next）和hnext指针（解决散列冲突的链表指针）。
  + 散列表通过链表法解决散列冲突，所以每个节点都会在两条链中。一条链是双向链表，另一条链是散列表中的拉链。前驱和后继指针是为了将节点串在双向链表中，hnext指针是为了将节点串在散列表的拉链中。
  + LRU缓存淘汰算法的3个主要操作如何做到时间复杂度为O(1)呢？
    - 首先，链表本身插入和删除一个节点的时间复杂度为O(1)，因为只需更改几个指针指向即可。
    - 接着，来分析查找操作的时间复杂度。当要查找一个数据时，通过散列表可实现在O(1)时间复杂度找到该数据，再加上前面说的插入或删除的时间复杂度是O(1)，所以总操作的时间复杂度就是O(1)。

2. Redis有序集合

2. 什么是有序集合？

* 在有序集合中，每个成员对象有2个重要的属性，即key（键值）和score（分值）。
* 不仅会通过score来查找数据，还会通过key来查找数据。

2. 有序集合的操作有哪些？

举个例子，比如用户积分排行榜有这样一个功能：可以通过用户ID来查找积分信息，也可以通过积分区间来查找用户ID。这里用户ID就是key，积分就是score。所以，有序集合的操作如下：

* 添加一个对象；
* 根据键值删除一个对象；
* 根据键值查找一个成员对象；
* 根据分值区间查找数据，比如查找积分在[100.356]之间的成员对象；
* 按照分值从小到大排序成员变量。

这时可以按照分值将成员对象组织成跳表结构，按照键值构建一个散列表。那么上面的所有操作都非常高效。

3. Java LinkedHashMap

和LRU缓存淘汰策略实现一模一样。支持按照插入顺序遍历数据，也支持按照访问顺序遍历数据。
三、课后思考

1. 上面所讲的几个散列表和链表组合的例子里，都是使用双向链表。如果把双向链表改成单链表，还能否正常工作？为什么呢？
1. 假设猎聘网有10万名猎头，每个猎头可以通过做任务（比如发布职位）来积累积分，然后通过积分来下载简历。假设你是猎聘网的一名工程师，如何在内存中存储这10万个猎头的ID和积分信息，让它能够支持这样几个操作：
1. 根据猎头ID查收查找、删除、更新这个猎头的积分信息；
1. 查找积分在某个区间的猎头ID列表；
1. 查找按照积分从小到大排名在第x位到第y位之间的猎头ID列表。

