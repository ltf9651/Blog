## HTTP

`http://www.baidu.com` 是个 URL，叫作统一资源定位符

### HTTP 请求的准备

1. 浏览器将域名发送给 DNS 服务器，让其解析为 IP 地址

1. 建立 TCP 连接

### HTTP 请求的构建

HTTP 报文
  - 请求行
    - GET、POST、PUT、DELETE 等
  - 请求的首部
    - Accept-Charset、Content-Type、Cache-control 等
  - 请求的正文实体

### HTTP 请求的发送

1. HTTP 协议基于 TCP 协议，也是用面向连接的方式发起请求，通过 steam 二进制流的方式传给对方，到了 TCP 层会把二进制流变成报文段发送给服务器

1. 在发送每个报文段的时候，都需要对方有一个回应 ACK 保证报文段可靠的到达，若无回应 TCP 层重新进行传输直到到达

1. TCP 层每发送一个报文的时候都需要加上源地址和目标地址，将这两个信息放到 IP 头，交给 IP 层进行传输

1. IP 层查看目标地址和自己是否在同一局域网，如果是就发送 ARP 协议请求目标地址对应的 MAC 地址，然后将源 MAC 和目标 MAC 放入 MAC 头发送出去；若不在同一局域网，就发送到网管，还是需要发送 ARP 协议获取网关的 MAC 地址，然后将源 MAC 地址和网关 MAC 放入 MAC 头发送出去

1. 网关收到包发现 MAC 符合，取出目标 IP 地址，根据路由协议找到下一跳的路由器，获取下一跳路由器的 MAC 地址将包发送给下一跳路由器

1. 路由器一跳一跳终于到达目标的局域网，此时最后一跳的路由器能发现目标地址就在自己的某一个出口的局域网上，在这个局域网上发送 ARP，获取这个目标地址的 MAC 地址将包发出去

1. 目标机器发现 MAC 地址符合，接收包；发现 IP 地址符合，根据 IP 头的协议项，知道自己上一层是 TCP 协议，于是解析 TCP 头，里面有序列号，查看虚列报是不是所需要的的，如果是就放入缓存然后返回一个 ACK，如果不是就丢弃；TCP 头还有端口号，HTTP 的服务器正在监听这个端口号，目标机器知道 HTTP 服务器要这个包，将包发送给 HTTP 服务器；HTTP 服务器的进程接收请求，将网页发送给客户端

### HTTP 返回的构建

HTTP 返回报文
  - 状态码
    - 200、404、504 等
  - 首部
    - Retry-After、Contrnt-Type 等
  - 实体

1. 构造好的 HTTP 报文会交给 Socket 发送，还是交给 TCP 层，让 TCP 层把返回的 HTML 分成一个个小的段，并且保证每个段都可靠到达

1. 这些短加上 TCP 头后交给 IP 层，然后把刚才的发送过程反走一遍，到达客户端

1. 客户端发现 MAC 地址符合、IP 地址符合，于是交给 TCP 层，根据序列号查看是不是所需要的的报文段，如果是就根据 TCP 头的端口号发给相应进程（浏览器，浏览器作为客户端也在监听某个端口）

1. 浏览器拿到 HTTP 报文，发现返回`200`，就从正文中将 HTML 拿出并展示

### HTTP 2.0

HTTP 1.1 在应用层以纯文本的形式进行通信。每次通信都要带完整的 HTTP 的头，而且不考虑 pipeline 模式的话，每次的过程总是像上面描述的那样一去一回。这样在实时性、并发性上都存在问题

HTTP2.0
  - 对 HTTP 的头进行一定压缩，将原来每次都要携带的大量 key value 在两端建立一个索引表，对相同的头只发送索引表中的索引
  - 将一个 TCP 的连接切分成多个流，每个流都有自己的 ID，流可以是客户端发往服务端也可以是服务端发往客户端
  - 将所有的传输信息分割为更小的消息和帧，并对它们采用二进制格式编码
  - HTTP 2.0 的客户端可以将多个请求分到不同的流中，然后将请求内容拆成帧，进行二进制传输
  - 这些帧可以打散乱序发送， 然后根据每个帧首部的流标识符重新组装，并且可以根据优先级，决定优先处理哪个流的数据

假设一个页面要发送三个独立的请求，一个获取 css，一个获取 js，一个获取图片 jpg。如果使用 HTTP 1.1 就是串行的，但是如果使用 HTTP 2.0，就可以在一个连接里，客户端和服务端都可以同时发送多个请求或回应，而且不用按照顺序一对一对应。

HTTP 2.0 解决了 HTTP 1.1 的队首阻塞问题，同时，也不需要通过 HTTP 1.x 的 pipeline 机制用多条 TCP 连接来实现并行请求与响应

减少了 TCP 连接数对服务器性能的影响，同时将页面的多个数据 css、js、 jpg 等通过一个数据链接进行传输，能够加快页面组件的传输速度

存在的问题
  - 基于 TCP 协议，TCP 协议在处理包时有严格顺序
  - 当其中一个数据包遇到问题，TCP 连接需要等待这个包完成重传才能继续进行
  - HTTP2.0 也会发生阻塞

### QUIC 协议

基于 UDP 协议

- 自定义连接机制
- 自定义重传机制
- 无阻塞的多路复用
- 自定义流量控制
