## TCP

- 顺序问题 ，稳重不乱
- 丢包问题，承诺靠谱
- 连接维护，有始有终
- 流量控制，把握分寸
- 拥塞控制，知进知退

### 三次握手

一开始，客户端和服务端都处于 CLOSED 状态

先是服务端主动监听某个端口，处于 LISTEN 状态

然后客户端主动发起连接 SYN，之后处于 SYNSENT 状态

服务端收到发起的连接，返回 SYN，并且 ACK 客户端的 SYN，之后处于 SYN-RCVD 状态

客户端收到服务端发送的 SYN 和 ACK 之后，发送 ACK 的 ACK，之后处于 ESTABLISHED 状态，因为它一发一收成功了

服务端收到 ACK 的 ACK 之后，处于 ESTABLISHED 状态，因为它也一发一收了

三次握手除了双方建立连接外，主要还是为了沟通一件事情，就是 TCP 包的序号的问题

每个连接都要有不同的序号。这个序号的起始序号是随着时间变化的

### 四次挥手

### 场景

A：B 啊，我不想玩了。

B：哦，你不想玩了啊，我知道了。

这个时候，还只是 A 不想玩了，也即 A 不会再发送数据，但是 B 能不能在 ACK 的时候，直接关闭呢？当然不可以了，很有可能 A 是发完了最后的数据就准备不玩了，但是 B 还没做完自己的事情，还是可以发送数据的，所以称为半关闭的状态。

这个时候 A 可以选择不再接收数据了，也可以选择最后再接收一段数据，等待 B 也主动关闭。

B：A 啊，好吧，我也不玩了，拜拜。

A：好的，拜拜

### 具体流程

断开连接时，当 A 请求断开时，A 进入 FIN_WAIT_1 状态

B 收到 A 的消息后发送 ACK，进入 CLOSE_WAIT 状态

A 收到 B 的消息后进入 FIN_WAIT_2，如果这时候 B 直接跑路，A 将一直处于此状态。TCP 协议没有对这个状态的处理，但是 Linux 可以通过调整 tcp_fin_timeout 设置超时时间

如果 B 没跑路，也发送了断开请求到达 A，A 再发送收到消息的 ACK 后，从 FIN_WAIT_2 状态结束。此时 TCP 协议要求 A 最后等待一段时间 TIME_WAIT，等待 B 收到 ACK

A 直接跑路还有一个问题是，A 的端口就直接空出来了，但是 B 不知道，B 原来发过的很多包很可能还在路上，如果 A 的端口被一个新的应用占用了，这个新的应用会收到上个连接中 B 发过来的包

等待的时间设为 2MSL，MSL 是 Maximum Segment Lifetime，报文最大生存时间，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃

还有一个异常情况就是，B 超过了 2MSL 的时间，依然没有收到它发的 FIN 的 ACK，怎么办呢？按照 TCP 的原理，B 当然还会重发 FIN，这个时候 A 再收到这个包之后，A 就表示，我已经在这里等了这么长时间了，已经仁至义尽了，之后的我就都不认了，于是就直接发送 RST，B 就知道 A 早就跑了
