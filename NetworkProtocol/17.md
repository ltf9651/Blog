****## 结

1. 当部署完应用后，通过 BGP 路由协议将外网 IP 让全世界知道可访问
1. 手机开机以后，在附近寻找基站 eNodeB，发送请求申请上网
1. 基站将请求发给 MME，MME 对手机进行认证和鉴权，还会请求 HSS 查询余额和地址
1. 当 MME 通过了手机的认证后开始建立两段隧道，一段是从 eNodeB 到 SGW，第二段是从 SGW 到 PGW，在 PGW 之外，就是互联网
1. PGW 为手机分配一个 IP 地址，手机上网都带着这个 IP
1. 手机打开 APP，解析应用网站的域名
1. 手机请求解析 DNS，GSLB 通过实现负载均衡，将结果 IP 地址返回给本地 DNS 服务器，本地 DNS 将结果缓存后返回给客户端
1. 一般应用的静态资源保存在 varnish 和 CDN
1. 开始下单后，网站对下单的情况提供 RESTful 下单接口，通过 HTTPS 协议进行请求
1. HTTPS 首先建立 TCP 连接（连接 APP 和负载均衡器 SLB）
1. TCP 进行三次握手
1. 一开始客户端和服务端都处于 CLOSED 状态，服务端先主动监听某个端口，处于 LISTEN
1. 客户端主动发起连接 SYN，之后处于 SYN-SENT 状态，服务端收到发起的连接，返回 SYN，并且 ACK 客户端的 SYN，然后处于 SYN-RCVD 状态
1. 客户端收到 SYN 和 ACK 后，发送服务端 ACK 的 ACK，之后处于 ESTABLISHED 状态，服务端收到客户端 ACK 的 ACK，也处于 ESTABLISHED 状态
1. TCP 连接建立完毕，进行 HTTPS 层建立连接，在 HTTPS 的交换过程中 TCP 层始终处于 ESTABLISHED
1. 客户端发送 Client Hello 消息到服务器，用铭文传输 TLS 版本信息、加密套件候选列表、压缩算法候选列表等信息，还会传一个随机数在协商对称密钥时使用
1. 服务器返回 Server Hello 消息告诉客户端服务器选择使用的版本、加密套件、压缩算法等，也传一个随机数用于后续的密钥协商
1. 服务器给客户端一个服务器端的证书，发送 Server Hello Done
1. 客户端不相信此证书，从自己信任的 CA 仓库中拿 CA 的证书里面的公钥去解密网站的证书，如果成功说明此网站可信
1. 证书验证完毕后客户端计算产生随机数字 Pre-Master，发送 Client Key Exchange 用于证书中的公钥加密，再发送给服务器，服务器可通过私钥解密
1. 上述的三个随机数可以再服务端和客户端产生相同的对称密钥
1. 有了对称密钥后客户端发送 Change Cipher Spec，与服务端都采用协商的通信密钥和加密算法进行加密通信
1. 客户端发送 Encrypted HandShake Message，将已经商定好的参数等采用协商密钥进行加密发送给服务端用于数据与握手验证
1. 服务端也发送 Change Cipher Spec，并且也发送 Encrypted HandShake Message
1. 当双方握手结束后就通过对称密钥进行加密传输
1. 客户端和服务端建立连接后发送下单请求的网络包
1. HTTP 的报文大概分为三大部分。第一部分是请求行，第二部分是请求的首部，第三部分才是请求的正文实体
1. HTTP 的请求报文格式拼接好后，APP 通过封装好的 Socket 程序将其交给下一层传输层
1. HTTP 协议是基于 TCP 协议的，所以它使用面向连接的方式发送请求，通过 Stream 二进制流的方式传给对方，到了 TCP 层，它会把二进制流变成一个的报文段发送给服务器
1. 在 TCP 头会有源端口号和目标端口号，源端口在手机端，往往是一个随机分配的；目标端口号是服务端监听的端口号
1. 在 IP 头里加上源地址和目标地址，当手机上网时 PGW 会给手机分配一个 IP 地址，就是源地址，目标地址则是负载均衡器的外网 IP 地址
1. 在 IP 层客户端查看目标地址和自己是否在统一局域网，通过 CIDR 子网掩码计算是否在同一网段，得出不在同一网段后，发送 ARP 协议获取网关的 MAC 地址，将网关 MAC 作为目标 MAC，自己的 MAC 作为源 MAC 放入 MAC 头发送出去
1. 对于手机来讲，默认的网关在 PGW 上，在移动网络里面，从手机到 SGW， 到 PGW 是有一条隧道的。在这条隧道里面，会将上面的这个包作为隧道的乘客协议放在里面，外面 SGW 和 PGW 在核心网机房的 IP 地址。网络包直到 PGW（PGW 是隧道的另一端）才将里面的包解出来，转发到外部网络。
1. 从手机发送出来的网络包结构
   - 源 MAC：手机也即 UE 的 MAC
   - 目标 MAC：网关 PGW 上面的隧道端点的 MAC
   - 源 IP：UE 的 IP 地址
   - 目标 IP：SLB 的公网 IP 地址
1. 进入隧道之后，要封装外层的网络地址，网络包的格式
   - 外层源 MAC：E-NodeB 的 MAC；
   - 外层目标 MAC：SGW 的 MAC；
   - 外层源 IP：E-NodeB 的 IP；
   - 外层目标 IP：SGW 的 IP；
   - 内层源 MAC：手机也即 UE 的 MAC；
   - 内层目标 MAC：网关 PGW 上面的隧道端点的 MAC；
   - 内层源 IP：UE 的 IP 地址；
   - 内层目标 IP：SLB 的公网 IP 地址。
1. 当隧道在 SGW 的时候，切换了一个隧道，会从 SGW 到 PGW 的隧道，此时网络包的格式
   - 外层源 MAC：SGW 的 MAC；
   - 外层目标 MAC：PGW 的 MAC；
   - 外层源 IP：SGW 的 IP；
   - 外层目标 IP：PGW 的 IP；
   - 内层源 MAC：手机也即 UE 的 MAC；
   - 内层目标 MAC：网关 PGW 上面的隧道端点的 MAC；
   - 内层源 IP：UE 的 IP 地址；
   - 内层目标 IP：SLB 的公网 IP 地址。
1. 在 PGW 的隧道端点将包解出来，转发出去的时候，一般在 PGW 出外部网络的路由器上，会部署 NAT 服务，将手机的 IP 地址转换为公网 IP 地址，当请求返回的时候，再 NAT 回来
1. 在 PGW 转发后的网络包
   - 源 MAC：PGW 出口的 MAC；
   - 目标 MAC：NAT 网关的 MAC；
   - 源 IP：UE 的 IP 地址；
   - 目标 IP：SLB 的公网 IP 地址。
1. 在 NAT 网关转发后的网络包
   - 源 MAC：NAT 网关的 MAC；
   - 目标 MAC：A2 路由器的 MAC；
   - 源 IP：UE 的公网 IP 地址；
   - 目标 IP：SLB 的公网 IP 地址
1. 出了 NAT 网关，就从核心网到达了互联网，每个运营商的网络成为自治系统 AS，每个 AS 都有边界路由器与外界建立连接
1. 在路由器之间需要通过 BGP 协议实现，BGP 又分为两类，eBGP 和 iBGP。自治系统之间、边界路由器之间使用 eBGP 广播路由。内部网络也需要访问其他的自治系统
1. 网站的 SLB 的公网 IP 地址早已经通过云平台的边界路由器，让全网都知道了。于是这个下单的网络包选择的下一跳是 A2，也即将 A2 的 MAC 地址放在目标 MAC 地址中。
1. 到达 A2 之后，从路由表中找到下一跳是路由器 C1，于是将目标 MAC 换成 C1 的 MAC 地址。到达 C1 之后，找到下一跳是 C2，将目标 MAC 地址设置为 C2 的 MAC。到达 C2 后，找到下一跳是云平台的边界路由器，于是将目标 MAC 设置为边界路由器的 MAC 地址
1. 在云平台的边界路由器，会将下单的包转发进来，经过核心交换，汇聚交换，到达外网网关节点上的 SLB 的公网 IP 地址
1. 如果网络包在传输过程中丢失，就需要 TCP 进行重发
1. TCP 通过维护 Sequence Number，滑动窗口协议进行重发机制
1. 整个 TCP 的发送，一开始会协商一个 Sequence Number，从这个 Sequence Number 开始，每个包都有编号
1. 滑动窗口将接收方的网络包分成四个部分
   - 已经接收，已经 ACK，已经交给应用层的包；
   - 已经接收，已经 ACK，未发送给应用层；
   - 已经接收，尚未发送 ACK；
   - 未接收，尚有空闲的缓存区域
1. 对于 TCP 层来讲，每一个包都有 ACK。ACK 需要从 SLB 回复到手机端，将上述的过程反走一遍
1. 如果发送方超过一定的时间没有收到 ACK，就会重新发送
1. 只有 TCP 层 ACK 过的包才会发送给应用层，并且只会发送一份，对于下单场景，应用层是 HTTP 层
1. TCP 虽然会重传，但是只有一个包可以到达 HTTP 层，所以 HTTP 层不会收到重复的包。为了防止重新发送 HTTP 的请求，RESTful API 需要实现幂等
1. 包从手机端到了 SLB 的公网 IP 所在的公网网口。由于匹配上了 MAC 地址和 IP 地址，因而将网络包收了进来
1. 在虚拟网关节点的外网网口上，会有一个 NAT 规则，将公网 IP 地址转换为 VPC 里面的私网 IP 地址
1. 当网络包里面的目标 IP 变成私有 IP 地址之后，虚拟路由会查找路由规则，将网络包从下方的私网网口发出来，此时网络包
   - 源 MAC：网关 MAC；
   - 目标 MAC：HAProxy 虚拟机的 MAC；
   - 源 IP：UE 的公网 IP；
   - 目标 IP：HAProxy 虚拟机的私网 IP。
1. 在虚拟路由节点上，也会有 OVS，将网络包封装在 VXLAN 隧道里面，VXLAN ID 就是给你的租户创建 VPC 的时候分配的。包的格式
   - 外层源 MAC：网关物理机 MAC；
   - 外层目标 MAC：物理机 A 的 MAC；
   - 外层源 IP：网关物理机 IP；
   - 外层目标 IP：物理机 A 的 IP；
   - 内层源 MAC：网关 MAC；
   - 内层目标 MAC：HAProxy 虚拟机的 MAC；
   - 内层源 IP：UE 的公网 IP；
   - 内层目标 IP：HAProxy 虚拟机的私网 IP。
1. 在物理机 A 上，OVS 会将包从 VXLAN 隧道里面解出来，发给 HAProxy 所在的虚拟机。HAProxy 所在的虚拟机发现 MAC 地址匹配，目标 IP 地址匹配，就根据 TCP 端口，将包发给 HAProxy 进程，因为 HAProxy 是在监听这个 TCP 端口的。因而 HAProxy 就是这个 TCP 连接的服务端，客户端是手机。对于 TCP 的连接状态、滑动窗口等，都是在 HAProxy 上维护的
1. HAProxy 发出去的网络包就认为 HAProxy 是客户端了，看不到手机端了
   - 源 MAC：HAProxy 所在虚拟机的 MAC；
   - 目标 MAC：Controller 层所在虚拟机的 MAC；
   - 源 IP：HAProxy 所在虚拟机的私网 IP；
   - 目标 IP：Controller 层所在虚拟机的私网 IP。
1. 包发出去之后，还是会被物理机上的 OVS 放入 VXLAN 隧道里面，网络包格式
   - 外层源 MAC：物理机 A 的 MAC；
   - 外层目标 MAC：物理机 B 的 MAC；
   - 外层源 IP：物理机 A 的 IP；
   - 外层目标 IP：物理机 B 的 IP；
   - 内层源 MAC：HAProxy 所在虚拟机的 MAC；
   - 内层目标 MAC：Controller 层所在虚拟机的 MAC；
   - 内层源 IP：HAProxy 所在虚拟机的私网 IP；
   - 内层目标 IP：Controller 层所在虚拟机的私网 IP。
1. 在物理机 B 上，OVS 会将包从 VXLAN 隧道里面解出来，发给 Controller 层所在的虚拟机。Controller 层所在的虚拟机发现 MAC 地址匹配，目标 IP 地址匹配，就根据 TCP 端口，将包发给 Controller 层的进程，因为它在监听这个 TCP 端口
1. 在 HAProxy 和 Controller 层之间，维护一个 TCP 的连接
1. Controller 层收到包之后，它是关心 HTTP 里面是什么的，于是解开 HTTP 的包，发现是一个 POST 请求，内容是下单购买
1. Controller 层会通过 RPC 调用这个组合服务层，进行下单的业务逻辑处理
1. 当下单更新到分布式数据库中之后，整个下单过程才算真正告一段落
