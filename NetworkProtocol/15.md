## RPC

RPC 格式
 - XID 唯一标识一对请求和回复。请求为 0，回复为 1。
 - RPC 有版本号，两端要匹配 RPC 协议的版本号。如果不匹配，就会返回 Deny，原因就是 RPC_MISMATCH。
 - 程序有编号。如果服务端找不到这个程序，就会返回 PROG_UNAVAIL。
 - 程序有版本号。如果程序的版本号不匹配，就会返回 PROG_MISMATCH。
 - 一个程序可以有多个方法，方法也有编号，如果找不到方法，就会返回 PROC_UNAVAIL。
 - 调用需要认证鉴权，如果不通过，则 Deny。
 - 最后是参数列表，如果参数无法解析，则返回 GABAGE_ARGS

### 传输过程

RPC 的传输需要一个状态机

1. 进入起始状态，查看 RPC 的传输层队列中有没有空闲的位置，可以处理新的 RPC 任务
1. 如果没有，说明太忙了，或直接结束或重试
1. 如果申请成功，就可以分配内存，获取服务的端口号，然后连接服务器
1. 连接的过程要有一段时间，因而要等待连接的结果，会有连接失败，或直接结束或重试。如果连接成功，则开始发送 RPC 请求，然后等待获取 RPC 结果，这个过程也需要一定的时间
1. 如果发送出错，可以重新发送
1. 如果连接断了，可以重新连接
1. 如果超时，可以重新传输
1. 如果获取到结果，就可以解码，正常结束

### 服务发现

1. RPC 程序启动的时候，会向 portmapper 注册
1. portmapper 会启动在一个众所周知的端口上，RPC 程序由于是用户自己写的，会监听在一个随机端口上，
1. 客户端要访问 RPC 服务端这个程序的时候，首先查询 portmapper，获取 RPC 服务端程序的随机端口，然后向这个随机端口建立连接，开始 RPC 调用

### XML 和 SOAP

原来的二进制 RPC 有很多缺点，格式要求严格，修改过于复杂，不面向对象，于是产生了基于文本的调用方式——基于 XML 的 SOAP

SOAP 有三大要素：协议约定用 WSDL、传输协议用 HTTP、服务发现用 UDDL

### GRPC

GRPC 是一种二进制，性能好，跨语言，还灵活，同时可以进行服务治理的多快好省的 RPC 框架，唯一不足就是还是要写协议文件

GRPC 使用 Protocol Buffers 作为二进制序列化协议，网络传输使用 HTTP 2.0，服务治理可以使用基于 Envoy 的 Service Mesh
