## Socket

在网络层，Socket 函数需要指定到底是 IPv4 还是 IPv6，分别对应设置为 AF_INET 和 AF_INET6。还要指定到底是 TCP 还是 UDP。TCP 基于数据流，设置为 SOCK_STREAM，而 UDP 是基于数据报的，设置为 SOCK_DGRAM

### 基于 TCP 协议的 Socket 调用

1. TCP 服务端先调用`bind`函数监听一个端口，给这个 Socket 赋予一个 IP 地址和端口

1. 服务端有了 IP 和端口号就可以调用`listen`函数进行监听，此时客户端就可以发起连接

1. 在内核中，为每个 Socket 维护两个队列，一个是已经建立了连接的队列，这时候的连接三次握手已经完毕，处于 established 状态；一个是还没有完全建立连接的队列，此时三次握手还没完成，处于 syn_rcvd 状态

1. 服务端调用`accept`函数，拿出一个已完成的连接进行处理，客户端通过`connect`函数发起连接，现在参数中指定要连接的 IP 和端口号，然后开始发起三次握手，内核会给客户端分配一个临时的端口，一旦握手成功，服务器端的`accept`会返回另一个 Socket

1. 监听的 Socket 和实际用来传数据的 Socket 是两个，一个叫做监听 Socket，一个叫作已连接 Socket

1. 连接成功建立后，双方开始通过`read`、`write`函数进行数据读写

#### 内核

TCP 的 Socket 是一个文件流，Socket 在 Linux 中就是以文件的形式存在的。除此之外，还存在文件描述符。写入和读出，也是通过文件描述符

在内核中，Socket 是一个文件，对应有文件描述符。每个进程都有一个数据结构 task_struct，里面指向一个文件描述符数组，列出这个进程打开的所有文件的文件描述符。里面包含一个 inode，指向 Socket 在内核中的 Socket 结构

Socket 结构
  - 发送队列
  - 接收队列

### 基于 UDP 协议的 Socket 调用

UDP 是没有连接的，所以不需要三次握手，也就不需要调用 listen 和 connect

UDP 的的交互仍然需要 IP 和端口号，也需要 bind

UDP 是没有维护连接状态的，因而不需要每对连接建立一组 Socket，而是只要有一个 Socket，就能够和多个客户端通信

因为没有连接状态，每次通信的时候，都调用 sendto 和 recvfrom，都可以传入 IP 地址和端口

### 高并发服务器 Socket

服务端端 TCP 连接四元组中只有对端 IP, 也就是客户端的 IP 和对端的端口，也即客户端的端口是可变的，因此，最大 TCP 连接数 = 客户端 IP 数×客户端端口数。对 IPv4，客户端的 IP 数最多为 2 的 32 次方，客户端的端口数最多为 2 的 16 次方，也就是服务端单机最大 TCP 连接数，约为 2 的 48 次方

服务端最大并发 TCP 连接数远不能达到理论上限。首先主要是文件描述符限制，Socket 都是文件，所以首先要通过 ulimit 配置文件描述符的数目；另一个限制是内存，按上面的数据结构，每个 TCP 连接都要占用一定内存，操作系统是有限的

#### 多进程方式

使用`fork`函数创建子进程，然后将基于已连接 Socket 的交互交给新的子进程处理

`fork`函数的作用是在父进程的基础上完全拷贝出一个子进程，会复制文件描述符的列表、内存空间、一条记录当前执行到哪一行程序的进程，复制出来的子进程和父进程几乎一致。fork 函数返回值是 0 是子进程，其他整数就是父进程

#### 多线程方式

通过`phread_create`创建一个线程，也是调用`do_fork`。新的线程共享很多资源（进程空间、文件描述符列表等），消耗更少的资源

#### IO 多路复用，一个线程维护多个 Socket

令某个线程盯住所有 Socket，都放在一个文件描述符集合 fd_set 中，然后调用`select`函数监听文件描述符集合的变化，发生变化的文件描述符在 fd_set 中对应的位设为 1，表示 Socket 可进行读写操作。再调用`select`监听下一轮的变化

每次 Socket 所在的文件描述符集合中有 Socket 发生变化的时候，都需要通过轮询的方式，也就是需要将全部项目都过一遍的方式来查看进度，这大大影响了一个项目组能够支撑的最大的项目数量

#### IO 多路复用，事件通知

当项目进度发生变化的时候，主动通知项目组，然后项目组再根据项目进展情况做相应的操作

`epoll`函数在内核中的实现不是通过轮询的方式，而是通过注册 callback 函数的方式，当某个文件描述符发送变化的时候，就会主动通知
