## 日志存储

Kafka 中的消息存储在磁盘上，消息以 topic 为基本单位进行归类

### 文件目录布局

- 一个分区对应一个 Log，为了防止 Log 过大，Kafka 引入了 LogSegment，将日志分段
- 向 Log 追加消息时是顺序写入，只有最后一个 LogSegment 才能执行写入操作，随着消息不断写入，当最后一个 segment 满足一定条件，创建一个新的 segment，新消息写入此 segment
- 为了方便消息检索，每个 LogSegment 日志文件都有偏移量和时间戳索引文件

### 消息压缩

Kafka 将多条消息一起进行压缩，一般情况下，生产者发送的压缩数据在 broker 中也是保持压缩状态进行存储，消费者从服务端获取到的也是压缩的消息，处理消息之前才会解压

### 日志索引

- Kafka 中的索引未见以稀疏索引的方式构造消息的索引，并不保证每个消息在索引文件中都有对应的索引项
- 稀疏搜因通过 MappedByteBuffer 将索引文件映射到内存中，加快索引的查询速度
- 在索引文件切分的时候会关闭当前正在写入的索引文件并设置成只读模式，同时以可读写模式创建新的索引文件

#### 偏移量索引

1. relativeOffset：消息对于 baseOffset 的偏移量，占 4 个字节
1. position：消息在日志分段文件中对应的物理位置，占 4 个字节

#### 时间戳索引

1. timestamp：当前日志分段最大的时间戳
1. relativeOffset：时间戳对应的消息的相对偏移量

### 日志清理

1. Log Retension：按照一定的保留策略直接删除不符合条件的日志分段
  1. 基于时间
  1. 基于日志大小
  1. 基于日志起始偏移量
1. Log Compaction：针对每个消息的 key 进行整合，对于相同 key 的不同 value 值只保留最后一个版本

### 磁盘存储

- Kafka 依赖于文件系统（磁盘）来存储和缓存消息
- Kafka 在设计时采用文件追加的方式写入消息，只能从日志文件尾部追加新的消息，不允许修改已写入的消息，属于顺序写盘，性能有保障

#### 页缓存

- 把磁盘中的数据缓存到内存中，对磁盘的访问变为对内存的访问，减少磁盘 I/O
- 当一个进程准备读取磁盘文件内容时，操作系统先查看待读取的数据所在页是否在页缓存中，如果存在则直接返回数据，避免磁盘 I/O；若没有命中则向磁盘发起读取请求并将读取的数据写入页缓存，再将数据返回给进程
- 如果进程要将数据写入磁盘，操作系统会检测数据对应的页是否在页缓存中，若不存在则先在也花奴才能中添加相应的项，最后将数据写入对应的页；被修改后的页成了脏页，操作系统会在合适的时间把脏页的数据写入磁盘，保证数据一致性
- 控制参数：vm.dirty_expire_centisecs、vm.dirty_writeback.centisecs
- 对于大量使用页缓存的 Kafka 应尽量避免内存交换，vm.swappiness=1

#### 磁盘 I/O 流程

- 磁盘 I/O 场景
  1. 用户调用标准 C 库进行 I/O 操作：应用程序 buffer->C 库标准 IObuffer->文件系统页缓存 ->通过具体文件系统到磁盘
  1. 用户调用文件 I/O：应用程序 buffer->文件系统页缓存 ->通过具体文件系统到磁盘
  1. 用户打开文件时使用 O_DIRECT，绕过页缓存直接读写磁盘
  1. 用户使用类似 dd 工具，并使用 direct 参数，绕过系统 cache 与文件啊系统直接写磁盘
- 发起 I/O 请求步骤
  1. 写操作（异步）：用户调用 fwrite 把数据写入 IObuffer 就返回，此时不会立即刷新到磁盘，会将多次小数据量相邻写操作先缓存起来合并，最终调用 write 函数一次性写入页缓存；数据写入页缓存后也不会立即刷新到磁盘，内核有 pdflush 线程不断检测脏页，判断是否要写入
  1. 读操作（同步）：用户调用 fread 到 IObuffer，如果成功则返回，否则继续；到页缓存中读取数据，成功则返回；发起 I/O 请求，读取数据后缓存 buffer 和 IObuffer 并返回
  1. I/O 请求处理：通用块层根据 I/O 请求构造一个或多个 bio 结构并提交给调度层：调度器将 bio 结构进行排序和合并组织称队列确保读写操作尽可能理想：将一个或多个进程的读（写）操作合并到一起读（写），尽可能变随机为顺序，优先满足读
- Linux I/O 调度策略
  1. NOOP：先进先出
  1. CFQ（默认）：按照 I/O 请求地址进行排序
  1. DEADLINE：为读写 I/O 分别提供 FIFO 队列
  1. ANTICIPATORY：为每个读 I/O 增设等待时间，满足随机 I/O 和顺序 I/O 混合场景

#### 零拷贝

- 零拷贝：将数据直接从磁盘文件复制到网卡设备中，而不需要经由应用程序之手，大大提高性能，减少内核和用户模式之间上下文切换
- 零拷贝通过 DMA 将文件内容复制到内核模式下的 Read Buffer 中，包含数据的位置和长度的信息的文件描述符加到 Socket Buffer，DMA 引擎直接将数据从内核模式中传递到网卡设备
- 非零拷贝情况
  1. 调用 read()，文件 A 内容被复制到内核模式的 Read Buffer
  1. CPU 控制将内核模式数据复制到用户模式下
  1. 调用 write()，用户模式下的内容复制到内核模式的 Socket Buffer
  1. 将内核模式系啊的 Socket Buffer 数据复制到网卡设备中传输
- 零拷贝只经历 2 次复制（非零拷贝 4 次），上下文切换 2 次（非零拷贝 4 次）
- Kafka 的顺序写和零拷贝为其提供了高性能保障
