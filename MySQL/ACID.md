## MySQL 事务的四大特性及其实现方式

### 原子性

事务的所有操作，要么全部完成，要么全部不完成，不会结束在某个中间环节

每一个写事务，都会修改 Buffer Pool，从而产生相应的 Redo  log ，这些 log 信息会被记录到 ib_logfiles 文件中。因为 Redo  log 是遵循 Write Ahead Log 的方式写的，所以事务是顺序被记录的。
任何 Buffer Pool 中的页被刷到磁盘之前，都会先写入到 log 文件中。

回滚（undo log ）
要保证原子性，就必须在异常发生时，对已经执行的操作进行回滚，此时就用到了 undo  log 。

未刷盘数据提交（redo log ）
除了回滚之外，还有一种场景是事务提交了， log 写入到 buffer pool 了，但是 buffer pool 的脏页 并没有刷盘，那此时怎么恢复呢？就需要用到 redo log 恢复数据

### 持久性

保证事务提交后不会因为宕机等原因导致数据丢失。数据写入之后，要保证不会丢失，在系统崩溃之后，也能恢复。实现主要基于 redo log 日志

因为 redo log 是有限的，那么宕机之后，redo log 之前的数据怎么恢复呢，这就结合 binlog

WAL（预写日志） 是用于保证事务的原子性和持久性。简单来讲，事务更新数据之前，先写日志，然后在更新数据。当系统崩溃时，如果事务还没写 WAL，那整个数据依然一致。如果事务只写了 WAL，未更新具体的数据页后崩溃，那恢复流程可以根据 WAL 日志，重做相关操作，保证数据一致性。

### 一致性

事务执行结束后，数据库的完整性约束没有被破坏，事务执行的前后都是合法的数据状态

事务追求的最终目标，一致性的实现既需要数据库层面的保障，也需要应用层面的保障

### 隔离性

保证事务执行尽可能不受其他事务影响。InnoDB 默认的隔离级别是 RR，RR 的实现主要基于锁机制、数据的隐藏列、undo log 和类 next-key lock 机制

事务之间的隔离，是通过锁机制实现的。当一个事务需要对数据库中的某行数据进行修改时，需要先给数据加锁。加了锁的数据，其它事务是不运行操作的，只能等待当前事务提交或回滚将锁释放。锁机制并不是一个陌生的概念，在许多场景中都会利用到不同实现的锁对数据进行保护和同步。而在 MySQL 中，根据不同的划分标准，还可将锁分为不同的种类
