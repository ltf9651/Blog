## 服务化

### 一体化架构

- 优势
  - 开发简单直接，代码和项目集中式管理
  - 只需要维护一个工程
  - 排查的时候方便，目标性强
- 缺点
  - 数据库连接数可能成为系统瓶颈
  - 模块之间依赖性强，耦合度高，测试麻烦
  - 部署成本高，上线更新不灵活

### 微服务化

#### 拆分原则

- 单一服务内部功能的高内聚、低耦合，每个服务只完成自己职责之内的内务
- 先粗略拆分，后逐渐细化
- 拆分的过程要尽量避免影响产品的日常功能迭代
- 服务接口的定义要具备可扩展性

#### 问题解决

- 服务接口的调用为跨进程的网络调用，会增加接口的响应时间，接口调用方需要知道服务部署在哪些机器的哪个端口，需要引入服务注册中心
- 一个服务所依赖的其他服务发生故障时，会产生大量的慢请求，该服务也出现性能问题，需要引入服务治理
- 服务拆分到多个进程中，一条请求的调用链路上涉及多个服务，一旦这个请求的响应时间增长或者出现错误，很难排查时哪个服务出现问题，需要引入分布式追踪工具和细致的服务监控

### RPC

- RPC 过程
  - 客户端首先将调用的类名、方法名、参数名、参数值等信息序列化成二进制流
  - 客户端将二进制流通过网络发送给服务端
  - 服务端接收到二进制流之后将它反序列化，得到需要调用的类名、方法名、参数名、参数值，在通过动态代理的方式，调用对应的方法得到返回值
  - 服务端将返回值序列化，在通过网络发送给客户端
  - 客户端对结果反序列化之后就可以得到调用的结果

#### 提升网络传输性能

- I/O 模型
  - 阻塞：数据不可用时，I/O 请求一直阻塞，直到数据返回
  - 非阻塞：数据不可用时，I/O 请求立即返回，直到被通知资源可用为止
- 资源处理
  - 同步处理：I/O 请求在读取或者写入数据时会阻塞，直到读取或者写入数据完成
  - 异步处理：I/O 请求在读取或者写入数据时立即返回，当操作系统处理完成 I/O 请求，并且将数据拷贝到用户提供的缓冲区，再通知应用 I/O 请求执行完成
- 常见 I/O 模型
  - 同步阻塞 I/O
  - 同步非阻塞 I/O
  - 同步多路 I/O 复用
  - 信号驱动 I/O
  - 异步 I/O
- Nagle 算法
  - 对连续的小数据包将这些数据在发送端暂存，直到小数据包累计到一个 MSS(Maximum Segment Size 最大分段大小）或者收到一个 Ack 为止
  - 解决：开启 tcp_nodelay

#### 合适的序列化方式

序列化：对象转换成二进制字符串

反序列化：二进制串转换成对象

- 考虑点
  - 性能
  - 跨语言、跨平台

常见协议：JSON、Thrift、Protobuf

- 性能要求不高，传输数据占用带宽不大，使用 JSON
- 性能要求高，Thrift、Protobuf
- 缓存中存储数据占用空间较大，Protobuf

### 注册中心

Zookeeper、ETCD、Nacos、Eureka

基本功能：提供服务地址的存储；当存储内容发生变化时，可以将变更的内容推送给客户端

服务注册和发现
  - 客户端与注册中心建立连接，并告诉注册中心对哪组服务感兴趣
  - 服务端向注册中心注册服务后，注册中心将最新的服务注册信息通知给客户端
  - 客户端拿到服务端的地址之后就可以向服务端发起调用请求

#### 服务状态管理

- 主动探测
  - 注册中心每隔一段时间探测服务端口是否可用，不可用则删除
  - 探测成本高、时间长、延迟长
  - 需要调用很多端口，容易导致占用，服务启动失败
- 心跳模式
  - 注册中心为每个连接上来的 RPC 服务节点，记录最近续约时间，RPC 服务节点在启动注册到注册中心后，按照一定时间间隔主动发送心跳包。注册中心接收到心跳包更新改服务的续约时间。注册中心会启动一个定时器，定期检测当前时间和节点，当续约时间差值达到阈值时就认为服务不可用
  - 需要增加保护策略，防止发生意外导致所有节点都被摘除的情况，导致整体服务全部宕机

### API 网关

将一些服务共有的功能整合到一起，独立部署为单独的一层，用来解决一些服务治理的问题

Kong、Zuul、Tyk

#### 网关的作用

- 入口网关
  - 提供客户端一个统一的接入地址，API 网关可以将用户的请求动态路由到不同的业务服务上，并且做一些必要的协议转换工作
  - 可以在网关中植入一些服务治理的策略，比如熔断、降级、分流等
  - 客户端的认证和授权的实现也可以放在 API 网关
  - 可以做一些与黑白名单相关的事情
  - 日志记录
- 出口网关
 - 对调用的外部 API 做统一的认证、授权、审计、访问控制等
