## 容器基础

进程：程序运行起来后计算器执行环境的总和（包含内存数据、寄存器、堆栈指令、文件等）

容器技术的核心：通过约束和修改进程的动态表现，从而为其创造一个“边界”

Docker 通过 Cgroups 技术制造约束的主要手段，Namespace 技术用于修改进程视图

```sh
$ docker run -it mybox /bin/sh
启动一个容器，在容器中执行 /bin/sh，-it分配一个命令行终端跟此容器交互


$ ps
PID USER TIME COMMAND
1 root 0:00 /bin/sh
10 root 0:00 ps
docker 执行的 /bin/sh 的 pid 为 1，意味着前面执行的 /bin/sh 和刚刚执行的 ps 已被 docker 隔离在一个跟宿主机完全不同的世界
```

Namespace 机制
 - 每当在宿主机上运行了一个 /bin/sh 程序，操作系统都会给它分配一个进程编号，比如 PID=100。这个编号是进程的唯一标识
 - 当通过 docker 把 /bin/sh 程序运行在一个容器中时，docker 会让此程序永远看不到 pid < 100 的前面的所有进程，此程序就会错误的认为自己是第 1 号进程，实际上此进程在宿主机上还是第 100 号进程
 - `int pid = clone(main_function, stack_size, SIGCHLD, NULL);`创建一个新的进程并返回 pid
 - `int pid = clone(main_function, stack_size, CLONE_NEWPID | SIGCHLD, NULL);`新进程会看到全新的进程空间，返回的 pid 为 1，真实 pid 还是 100

docker 容器技术实际上就是在创建容器进程时，指定这个进程所需要的启动的一组 Namespace 参数，这样容器就只能看到当前 Namespace 锁限定的资源、文件、设备、状态、配置等，对于宿主机以及其他不相关的程序就都看不到，所以**容器其实就是一种特殊的进程**

Cgroups：限制一个进程组能够使用的资源上限（CPU、内存、带宽等），通过 Cgroups 避免容器里的某个进程把所有资源吃光

一个正在运行的 Docker 容器，其实就是一个启用了多个 Linux Namespace 的应用进程，而这个进程能够使用的资源量，则受 Cgroups 配置的限制

### 和虚拟机区别

虚拟机实现资源隔离的方法是利用独立的 OS，并利用 Hypervisor 虚拟化 CPU、内存、IO 设备等实现的，资源消耗和占用大

容器里的应用和宿主机其他进程一样都由宿主机操作系统统一管理，docker 起旁路式辅助和管理作用

隔离程度
  - 虚拟机更彻底
  - 容器只是运行在宿主机上的一种特殊的进程，那么多个容器之间使用的就还是同一个宿主机的操作系统内核
  - docker 无法隔离系统时间
