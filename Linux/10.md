## 高性能服务器程序框架

- 服务器主要模块
  - I/O 处理单元
  - 逻辑单元
  - 存储单元

### 服务器模型

#### C/S 模型

- 服务器启动后首先创建一个（或多个）监听 socket，并调用 bind 函数将其绑定到服务器感兴趣的端口上，然后调用 listen 函数等待客户端连接
- 服务器稳定运行后，客户端调用 connect 函数向服务器发起连接
- 监听到连接服务器后，服务器调用 accept 接收，并分配一个逻辑单元为新的连接服务（逻辑单元可以是新创建的子进程、子线程或其他）
- 逻辑单元读取客户端请求并处理，将处理结果返回给客户端
- 缺点：访问量过大时服务器压力大

#### P2P 模型

- 每台机器在消耗服务的同时也给别人提供服务，使资源冲分、自由的共享
- 缺点：当用户之间传输的请求过大，负载会加重

### 服务器编程框架

- 模块
  - I/O 处理单元
    - 等待并接受新的客户端连接，将服务器响应数据返还给客户端
    - 实现负载均衡
  - 逻辑单元
    - 分析并处理客户数据，将结果传递给 I/O 处理单元或直接发送给客户端
    - 服务器拥有多个逻辑单元以实现堆多个任务的并行处理
  - 网络存储单元
    - 数据库、缓存、文件、服务器
  - 请求队列
    - 各单元之间的通信方式
    - 各台服务器之间预先建立的、静态的、永久的 TCP 连接

### I/O 模型

- I/O 模型同步、异步区分
  - 同步：内核向应用程序通知的是就绪事件，应用程序完成 I/O 读写
  - 异步：内核向应用程序通知的是完成事件，内核完成 I/O 读写
- I/O 通知机制：再用程序通过 I/O 复用函数向内核注册一组事件，内核通过 I/O 复用函数把其中就绪的事件通知给应用程序
- I/O 复用函数：select、poll、epoll_wait
- 同步 I/O 模型
  - 阻塞 I/O：程序阻塞于读写函数
  - I/O 复用：程序阻塞于 I/O 复用系统调用，但可是同时监听多个 I/O，对 I/O 本身读写为非阻塞
  - 信号驱动 I/O：信号出发读写就绪时间，用户程序执行读写操作，程序没有阻塞阶段
- 同步 I/O 模型要求用户代码自行执行 I/O 操作*将数据从内核缓冲区读入用户缓冲区，或将数据从用户缓冲区写入内核缓冲区）
- 异步 I/O 模型由内核执行 I/O 操作，内核执行读写并处罚读写完成时间，程序没有阻塞阶段

### 高效事件处理模式

- 服务器事件
  - I/O 事件
  - 信号事件
  - 定时事件
- 处理模式
  - Reactor（同步 I/O)
  - Proactor（异步 I/O)

#### Reactor

- 要求主线程（I/O 处理单元）只负责监听文件描述上是否有事件发生，有的话立即将该事件通知工作线程（逻辑单元）
- 主线程此外不做其他任何工作，读写数据、接收以及处理连接均由工作线程完成
- 工作流程（epoll_wait）
  - 主线程往 epoll 内核事件表中注册 socket 上的读就绪事件
  - 主线程调用 epoll_wait 等待 socket 上有数据可读
  - 当 socket 上有数据可读时，epoll_wait 通知主线程，主线程将 socket 可读事件放入请求队列
  - 睡眠在请求队列上的某个工作线程被唤醒，他从 socket 读取数据并处理客户请求，然后往 epoll 内核事件表中注册该 socket 上的写就绪事件
  - 主线程调用 epoll_wait 等待 socket 可写
  - 当 socket 可写，epoll_wait 通知主线程，主线程将 socket 科协时间放入请求队列
  - 睡眠在请求队列上的某个工作线程被唤醒，往 socket 上写入服务器处理客户请求的结果

#### Proactor

- Proactor 将所有 I/O 操作都交给主线程和内核来处理，工作线程仅仅负责业务逻辑
- 工作流程（aio_read，aio_write）
  - 主线程调用 aio_read 函数向内核注册 socket 上的读完成事件，并告诉内核用户读缓冲区的位置，以及读操作完成时间如何通知应用程序
  - 主线程继续处理其他逻辑
  - 当 socket 上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，通知应用程序数据已经可用
  - 应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求，工作线程处理完成后调用 aio_write 向内核注册 socket 上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操作完成时如何通知应用程序
  - 主线程继续处理其他逻辑
  - 当用户缓冲区的数据写入 socket 后，内核将向应用程序发送一个信号，通知应用程序数据已经发送完毕
  - 应用程序预先定义好的信号处理函数选择一个工作线程进行善后处理，比如决定是否关闭 socket

### 高效并发模式

#### 半同步 / 半异步模式

- 同步：程序完全按照代码序列的顺序执行
- 异步：程序的执行需要由系统事件来驱动
- 同步线程：效率较低，实时性较差，逻辑简单
- 异步线程：效率高，实时性强，相对复杂，难于调试和扩展，不适合于大量的并发
- 半同步 / 半异步模式中
  - 同步线程：处理客户逻辑
  - 异步线程：处理 I/O 事件，监听到客户请求后将其封装成请求对象并插入请求队列中，请求队列将通知某个工作在同步模式的工作线程来读取并处理请求对象
- 缺点
  - 主线程和工作线程共享请求队列。主线程往请求队列中添加任务，或者工作线程从请求队列中取出任务，都需要对请求队列加锁保护，耗费 CPU 时间
  - 每个工作线程在同一时间只能处理一个客户请求，如果客户数量多且工作线程少，则请求队列中将堆积很多任务对象，客户端响应速度会变慢。若通过增加工作线程来解决这一问题，工作线程的切换也将耗费大量 CPU 时间

#### 领导者 / 追随者模式

- 多个工作线程轮流获得事件源集合，轮流监听、分发并处理事件
- 在任意时间点，程序都仅有一个领导者线程，负责监听 I/O 事件，其他线程为追随者，休眠在线程池中等待成为新的领导者
- 当前的领导者检测到 I/O 事件首先将从线程池推选出新的领导者线程，然后处理 I/O 事件，此时新的领导者等待新的 I/O 事件，而原来的领导者处理 I/O 事件，实现并发
- 缺点：仅支持一个事件源集合，无法让每个工作线程独立的管理多个客户端连接
- 组件
  - 句柄集（HandleSet）
    - 表示 I/O 资源，是一个文件描述符
    - 管理众多句柄，使用`wait_for_event`监听这些句柄上的 I/O 事件，并将其中的就绪事件通知给领导者线程
    - 领导者调用绑定到 Handle 上的事件处理器（EventHandler）来处理事件
    - 使用`register_handle`实现领导者将 Handle 和事件处理器的绑定
  - 线程集（ThreadSet）
    - 所有工作线程的管理者
    - 负责各线程之间的同步（Synchronizer，避免竞态条件），以及新领导者的推选
    - 线程状态
      - Leader：负责等待句柄集上的 I/O 事件
      - Processing：线程正在处理事件。领导者检测到 I/O 事件后转移到 Processing 处理该事件，并调用`promote_new_leader`推选新的领导者，也可以指定其他追随者来处理事件（Event Handoff），此时领导者地位不变。当处于 Processing 状态的线程处理完事件后，若果当前线程集中没有领导者，则它将成为新的领导者，否则转为追随者
      - Follower：调用线程集的`join`等待成为新的领导者，也可被当前领导者指定完成新的任务
  - 事件处理器（EventHandler）
    - 包含一个或多个回调函数`handle_event`，用于处理事件对应的业务逻辑
    - 事件处理器在使用前需要被绑定到某个句柄上，当该句柄上有事件发生，领导者就执行与之绑定的事件处理器中的回调函数
  - 具体的事件处理器（ConcreteEventHandler）
    - 事件处理器的派生类
    - 必须重新实现基类的`handle_event`方法，以处理特定的任务

### 有限状态机（finite state machine）

[看不懂，先贴个链接](https://zhuanlan.zhihu.com/p/46347732)
