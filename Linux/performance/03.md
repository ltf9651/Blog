## CPU 上下文切换

Linux 所支持的任务操作远大于 CPU 数量，这些任务并不是真正同时运行，而是系统在很短时间内将 CPU 轮流分配给他们，造成多任务同时运行的错觉

Linux 在每个任务运行前，CPU 都需要知道任务从哪里加载，又从哪里开始运行，需要系统事先帮他设置好 CPU 寄存器和程序计数器

CPU 寄存器：CPU 内置的容量小，但速度极快的内存

程序计数器：用来存储 CPU 正在执行的指令位置、或者即将执行的下一条指令位置

CPU 上下文包括 CPU 寄存器和程序计数器

CPU 上下文切换：先把前一个任务的 CPU 上下文保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器指定的新位置，运行新任务

CPU 上下文文切换场景
  - 进程上下文切换
  - 线程上下文切换
  - 中断上下文切换

过多的上下文切换，会把 CPU 时间消耗在寄存器、内核栈以及虚拟内存等数据的保存和恢复上，从而缩短进程真正运行的时间，导致系统的整体性能大幅下降

### 进程上下文切换

Linux 按特权等级，把进程的运行空间分为内核空间和用户空间

内核空间（Ring 0）拥有最高权限，可直接访问所有资源

用户空间（Ring 3）只能访问受限资源，不能直接访问内存等硬件设备，必须通过系统调用陷入到内核中才能访问这些特权资源

进程可以在用户空间和内核空间运行。在用户空间运行时称为进程的用户态，陷入内核空间时称为进程的内核态

从用户态到内核态的转变，需要通过系统调用来完成，系统调用的过程会发生 CPU 上下文切换。比如当查看文件内容时，就需要多次系统调用来完成：首先调用 open() 打开文件，然后调用 read() 读取文件内容，并调用 write() 将内容写到标准输出，最后再调用 close() 关闭文件

CPU 寄存器原来用户态的指令位置先保存，为了执行内核态代码，CPU 寄存器更新为内核态指令的新位置，最后跳转到内核态运行内核任务，系统调用结束后 CPU 寄存器恢复到原来保存的用户态，再切换到用户空间继续运行进程。**一次系统调用发生两次 CPU 上下文切换**

进程上下文切换是指从一个进程切换到另一个进程运行，而系统调用过程中一直在同一个进程运行，每次上下文切换都需要几十纳秒到数微秒的 CPU 时间

系统调用过程通常称为特权模式切换而不是上下文切换

进程是由内核来管理和调度的，进程的切换只能发生在内核态，进程的上下文包括了虚拟内存、栈、全局变量等用户空间的资源以及内核堆栈、寄存器等内核空间的状态

进程的上下文切换就比系统调用时多了一步：在保存当前进程的内核状态和 CPU 寄存器之前，需要先把该进程的虚拟内存、栈等保存下来；而加载了下一进程的内核态后，还需要刷新进程的虚拟内存和用户栈

Linux 通过 TLB（Translation Lookaside Buffer）来管理虚拟内存到物理内存的映射关系。当虚拟内存更新后，TLB 也需要刷新，内存的访问也会随之变慢。特别是在多处理器系统上，缓存是被多个处理器共享的，刷新缓存不仅会影响当前处理器的进程，还会影响共享缓存的其他处理器的进程

Linux 为每个 CPU 都维护了一个就绪队列，将活跃进程（即正在运行和正在等待 CPU 的进程）按照优先级和等待 CPU 的时间排序，然后选择最需要 CPU 的进程，也就是优先级最高和等待 CPU 时间最长的进程来运行

进程执行完终止了，它之前使用的 CPU 会释放出来，这个时候再从就绪队列里，拿一个新的进程过来运行

进程切换场景：时间片轮询，系统资源不足，sleep 函数挂起，更高的进程运行，硬件中断

### 线程上下文切换

线程是调度的基本单位，而进程则是资源拥有的基本单位，内核中的调度任务，实际上的调度对象是线程，而进程只是给线程提供了虚拟内存、全局变量等资源

当进程只有一个线程时，可以认为进程就等于线程

当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源，这些资源在上下文切换时不需要修改

线程有私有数据，比如栈和寄存器等，这些在上下文切换时需要保存

上下文切换情况
  - 前后两个线程属于不同进程。资源不共享所有切换过程和进程切换一样
  - 前后两个线程同属一个进程。虚拟内存共享，切换时虚拟内存这些共享资源保持不懂，只需要切换线程的私有数据、寄存器等不共享的数据

多线程切换比多进程切换消耗更少的资源

### 中断上下文切换

为了快速响应硬件的时间，中断处理会打断进程的正常调度和执行，转而调用中断处理程序，响应设备时间。在打断其他进程时，需要将进程当前状态保存下来，在中断结束后进程任然可以从原来的状态恢复运行

中断上下文切换不涉及进程的用户态，所以打断处于用户态的进程不需要保存和恢复进程的用户态资源。中断的上下文只包括内核态中断服务程序执行所必须的状态，包括 CPU 寄存器、内存堆栈、硬件中断参数等

对同一个 CPU，中断处理比进程拥有更高优先级，所以中断上下文切换不会和进程上下文切换同时发生

中断上下文切换也需要消耗 CPU，切换次数过多也会耗费大量的 CPU，甚至严重降低系统的整体性能
