## CPU 上下文切换

Linux 作为一个多任务操作系统，将每个 CPU 的时间划分为很短的时间片，再通过调度器轮流分配给各个任务使用，因此造成多任务同时运行的错觉

Linux 在每个任务运行前，CPU 都需要知道任务从哪里加载，又从哪里开始运行，需要系统事先帮他设置好 CPU 寄存器和程序计数器

CPU 寄存器：CPU 内置的容量小，但速度极快的内存

程序计数器：用来存储 CPU 正在执行的指令位置、或者即将执行的下一条指令位置

CPU 上下文包括 CPU 寄存器和程序计数器

CPU 上下文切换：先把前一个任务的 CPU 上下文保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器指定的新位置，运行新任务

CPU 上下文文切换场景
  - 进程上下文切换
  - 线程上下文切换
  - 中断上下文切换

过多的上下文切换，会把 CPU 时间消耗在寄存器、内核栈以及虚拟内存等数据的保存和恢复上，从而缩短进程真正运行的时间，导致系统的整体性能大幅下降

### 进程上下文切换

Linux 按特权等级，把进程的运行空间分为内核空间和用户空间

内核空间（Ring 0）拥有最高权限，可直接访问所有资源

用户空间（Ring 3）只能访问受限资源，不能直接访问内存等硬件设备，必须通过系统调用陷入到内核中才能访问这些特权资源

进程可以在用户空间和内核空间运行。在用户空间运行时称为进程的用户态，陷入内核空间时称为进程的内核态

从用户态到内核态的转变，需要通过系统调用来完成，系统调用的过程会发生 CPU 上下文切换。比如当查看文件内容时，就需要多次系统调用来完成：首先调用 open() 打开文件，然后调用 read() 读取文件内容，并调用 write() 将内容写到标准输出，最后再调用 close() 关闭文件

CPU 寄存器原来用户态的指令位置先保存，为了执行内核态代码，CPU 寄存器更新为内核态指令的新位置，最后跳转到内核态运行内核任务，系统调用结束后 CPU 寄存器恢复到原来保存的用户态，再切换到用户空间继续运行进程。**一次系统调用发生两次 CPU 上下文切换**

进程上下文切换是指从一个进程切换到另一个进程运行，而系统调用过程中一直在同一个进程运行，每次上下文切换都需要几十纳秒到数微秒的 CPU 时间

系统调用过程通常称为特权模式切换而不是上下文切换

进程是由内核来管理和调度的，进程的切换只能发生在内核态，进程的上下文包括了虚拟内存、栈、全局变量等用户空间的资源以及内核堆栈、寄存器等内核空间的状态

进程的上下文切换就比系统调用时多了一步：在保存当前进程的内核状态和 CPU 寄存器之前，需要先把该进程的虚拟内存、栈等保存下来；而加载了下一进程的内核态后，还需要刷新进程的虚拟内存和用户栈

Linux 通过 TLB（Translation Lookaside Buffer）来管理虚拟内存到物理内存的映射关系。当虚拟内存更新后，TLB 也需要刷新，内存的访问也会随之变慢。特别是在多处理器系统上，缓存是被多个处理器共享的，刷新缓存不仅会影响当前处理器的进程，还会影响共享缓存的其他处理器的进程

Linux 为每个 CPU 都维护了一个就绪队列，将活跃进程（即正在运行和正在等待 CPU 的进程）按照优先级和等待 CPU 的时间排序，然后选择最需要 CPU 的进程，也就是优先级最高和等待 CPU 时间最长的进程来运行

进程执行完终止了，它之前使用的 CPU 会释放出来，这个时候再从就绪队列里，拿一个新的进程过来运行

进程切换场景：时间片轮询，系统资源不足，sleep 函数挂起，更高的进程运行，硬件中断

### 线程上下文切换

线程是调度的基本单位，而进程则是资源拥有的基本单位，内核中的调度任务，实际上的调度对象是线程，而进程只是给线程提供了虚拟内存、全局变量等资源

当进程只有一个线程时，可以认为进程就等于线程

当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源，这些资源在上下文切换时不需要修改

线程有私有数据，比如栈和寄存器等，这些在上下文切换时需要保存

上下文切换情况
  - 前后两个线程属于不同进程。资源不共享所有切换过程和进程切换一样
  - 前后两个线程同属一个进程。虚拟内存共享，切换时虚拟内存这些共享资源保持不懂，只需要切换线程的私有数据、寄存器等不共享的数据

多线程切换比多进程切换消耗更少的资源

### 中断上下文切换

为了快速响应硬件的时间，中断处理会打断进程的正常调度和执行，转而调用中断处理程序，响应设备时间。在打断其他进程时，需要将进程当前状态保存下来，在中断结束后进程任然可以从原来的状态恢复运行

中断上下文切换不涉及进程的用户态，所以打断处于用户态的进程不需要保存和恢复进程的用户态资源。中断的上下文只包括内核态中断服务程序执行所必须的状态，包括 CPU 寄存器、内存堆栈、硬件中断参数等

对同一个 CPU，中断处理比进程拥有更高优先级，所以中断上下文切换不会和进程上下文切换同时发生

中断上下文切换也需要消耗 CPU，切换次数过多也会耗费大量的 CPU，甚至严重降低系统的整体性能

### 查看上下文切换

```sh
# 每隔5秒输出
> vmstat 5
procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu-----
 r  b   swpd   free   buff  cache     si   so    bi   bo   in   cs  us   sy  id wa st
 4  0      0 663520 711884 2677332    0    0    14   116    1    0   8    4  87  0  0
```

- cs：每秒上下文切换次数
- in：每秒中断次数
- r：就绪队列长度，也就是正在运行和等待 CPU 的进程数
- b：处于不可中断睡眠状态的进程数

```sh
# 每隔5秒输出
> pidstat -w 5
01:53:30 AM       PID   cswch/s nvcswch/s  Command
```

- cswch：每秒资源上下文切换次数
- nvcswch：每秒非自愿上下文切换次数
- 自愿：进程无法获取所需资源导致的上下文切换。例如 I/O、内存等资源不足
- 非自愿：进程由于时间片已到等原因，被系统强制调度进而发生的上下文切换。例如大量进程都在争抢 CPU

### 测试、

```sh
# 监测上下文切换次数
> vmstat 1 1

# 以 10 个线程运行 5 分钟的基准测试，模拟多线程切换的问题
> sysbench --threads=10 --max-time=300 threads run

# -wt 参数表示输出线程的上下文切换指标
> pidstat -wt 1

# 查看中断情况
> watch -d cat /proc/interrupts
```

自愿上下文切换变多了，说明进程都在等待资源，有可能发生了 I/O 等其他问题

非自愿上下文切换变多了，说明进程都在被强制调度，也就是都在争抢 CPU，说明 CPU 的确成了瓶颈

中断次数变多了，说明 CPU 被中断处理程序占用，还需要通过查看 /proc/interrupts 文件来分析具体的中断类型。
