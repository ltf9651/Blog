## 文件系统

磁盘是一个存储设备（确切地说是块设备），可以被划分为不同的磁盘分区。而在磁盘或者磁盘分区上，还可以再创建文件系统，并挂载到系统的某个目录中。这样，系统就可以通过这个挂载
录，来读写文件

磁盘是存储数据的块设备，也是文件系统的载体。所以，文件系统确实还是要通过磁盘，来保证数据的持久化存储

在读写普通文件时，I/O 请求会首先经过文件系统，然后由文件系统负责，来与磁盘进行交互。而在读写块设备文件时，会跳过文件系统，直接与磁盘交互，也就是所谓的“裸 I/O”

文件系统管理的缓存，其实就是 Cache 的一部分。而裸磁盘的缓存，用的是 Buffer

磁盘位系统提供了最基本的持久化存储，文件系统则在磁盘的基础上提供了一个用来管理文件的树状结构

### 索引节点和目录项

文件系统为每个文件都分配两个数据结构，索引节点和目录项
  - 索引节点（inode）
    - 存储在磁盘中的数据
    - 记录文件的元数据，持久化到磁盘
    - 每个文件的唯一标志
  - 目录项（dentry）：记录文件的名字、索引节点指针以及其他目录项的关联关系
    - 多个关联的目录项构成文件系统的目录结构
    - 目录项是由内核维护的一个内存数据结构，也被叫做目录项缓存
    - 本身就是一个内存缓存

磁盘读写的最小单位是扇区，然而扇区只有 512B 大小，如果每次都读写这么小的单位，效率低

文件系统把连续的扇区组成了逻辑块，然后每次都以逻辑块为最小单元，来管理数据。常见的逻辑块大小为 4KB，也就是由连续的 8 个扇区组成

磁盘在执行文件系统格式化时，会被分成三个存储区域
  - 超级块：存储整个文件系统的状态
  - 索引节点区：用来存储索引节点
  - 数据块区：存储文件数据

Linux 文件系统四大基本要素
  - 目录项
  - 索引节点
  - 逻辑块
  - 超级块

### 虚拟文件系统

虚拟文件系统 VFS（Virtual File System）：Linux 内核在用户进程和文件系统中间引入的抽象层

VFS 提供一组所有文件系统都支持的数据结构和标准接口，用户进程和内和其他子系统只需要跟统一接口进行交互，无需关心底层实现细节

Linux 文件系统
  - 基于磁盘的文件系统
    - 数据直接存储在计算机本地挂在的磁盘
    - Ext4、XFS、OverlayFS 等
  - 内存文件系统
    - 不需要任何磁盘分配存储空间，但占用内存
    - 主要向用户空间导出层次化的内核对象
    - /proc、/sys
  - 网络文件系统
    - 用来访问其他计算机数据的文件系统
    - NFS、SMB、iSCSI 等
  - 这些文件系统都要先挂载到 VFS 目录树的某个子目录（挂载点）才能访问其中的文件

### 文件系统 I/O

`cat`：首先调用 open()，打开一个文件；然后调用 read()，读取文件的内容；最后再调用 write()，把文件内容输出到控制台的标准输出中

I/O 类型
  - 是否利用标准库缓存
    - 缓冲 I/O：利用标准库缓存加速文件访问，标准库内部再通过系统调度访问文件
    - 非缓冲 I/O：直接通过系统调用访问文件，不再经过标准库缓存
  - 是否利用操作系统的页缓存
    - 直接 I/O：跳过操作系统的页缓存，直接和文件系统交互来访问
    - 非直接 I/O：文件读写时先经过系统的页缓存，再由内核或额外的系统调用真正写入磁盘
  - 应用程序是否阻塞自身运行
    - 阻塞 I/O：应用程序执行 I/O 操作后如果没有获得响应，就阻塞当前线程
    - 非阻塞 I/O：应用程序执行 I/O 操作后不会阻塞当前线程，可继续执行其他任务，在通过轮询或事件通知的形式获取调用的结果
  - 是否等待响应结果
    - 同步 I/O：收到 I/O 请求后，系统不会立刻响应，；等到处理完成，系统才会通过系统调用的方式，告诉应用程序 I/O 结果
    - 非同步 I/O：收到 I/O 请求后，系统会先告诉应用程序 I/O 请求已经收到，随后去异步处理，等 I/O 完成后响应通过事件通知的方式告诉应用程序

### 性能观测

明明碰到了空间不足的问题，可是用 df 查看磁盘空间后，却发现剩余空间还有很多，可以给 df 命令加上 -i 参数，查看索引节点的使用情况，索引节点空间不足，但磁盘空间充足时，很可能就是过多小文件导致的，一般来说，删除这些小文件，或者把它们移动到索引节点充足的其他磁盘中

内核使用 Slab 机制，管理目录项和索引节点的缓存，具体到每一种 Slab 缓存，需查看 /proc/slabinfo
